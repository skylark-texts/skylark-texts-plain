{"version":3,"sources":["skylark-texts-plain.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-texts-plain.js","sourcesContent":["define('skylark-texts-plain/plain',[\r\n\t\"skylark-langx/skylark\"\r\n],function(skylark){\r\n\treturn skyalark.attach(\"plain.plain\")\r\n});\ndefine('skylark-texts-plain/position',[\r\n  \"skylark-langx/klass\",\r\n  \"skylark-langx/objects\",\r\n  \"./plain\"\r\n],function(klass,objects,plain) {\r\n  // POSITION OBJECT (original : line/pos.js)\r\n\r\n  // A Position instance represents a position within the text.\r\n  var Position = klass({\r\n    _construct : function(line,ch,sticky = null) {\r\n      this.line = line; \r\n      this.ch = ch;\r\n      this.sticky = sticky;\r\n    },\r\n    compareTo : function(other) {\r\n      return other && (this.line - other.line || this.ch - other.ch); \r\n    },\r\n\r\n    clone : function() {\r\n      return new Position(this.line,thie.ch);\r\n    },\r\n\r\n    equals : function(other) {\r\n        return other && (this.sticky == other.sticky && this.compareTo(other) == 0);    \r\n    },\r\n\r\n    clipToLen : function(linelen) {\r\n        let ch = this.ch;\r\n        if (ch == null || ch > linelen) {\r\n            return new Position(this.line, linelen);          \r\n        } else if (ch < 0) {\r\n            return new Position(this.line, 0);\r\n        } else {\r\n            return this;\r\n        }\r\n    }\r\n  });\r\n\r\n  // Compare two positions, return 0 if they are the same, a negative\r\n  // number when a is less, and a positive number otherwise.\r\n  Position.compare = function cmp(a, b) { \r\n    return a.compareTo(b);\r\n  };\r\n\r\n  Postion.copy = function copyPos(x) {\r\n    return x.clone();\r\n  }\r\n\r\n  Position.max = function maxPos(a, b) { \r\n    return cmp(a, b) < 0 ? b : a; \r\n  };\r\n\r\n  Position.min = function minPos(a, b) { \r\n    return cmp(a, b) < 0 ? a : b; \r\n  };\r\n\r\n  Position.equal = function equalCursorPos(a,b) {\r\n    return a && a.equals(b);\r\n  };\r\n\r\n  return plain.Position = Position;\r\n\r\n});\r\n\ndefine('skylark-texts-plain/range',[\r\n  \"skylark-langx/klass\",\r\n  \"./plain\",\r\n  \"./position\"\r\n],function(klass,plain,Postion) {\r\n  // Original: model/selection.js\r\n  \r\n  var Range = klass({\r\n    klassName : \"Range\",\r\n\r\n    _construct : function(anchor, head) {\r\n      this.anchor = anchor; \r\n      this.head = head;\r\n    },\r\n\r\n    from: function() { \r\n      return Positon.min(this.anchor, this.head); \r\n    },\r\n    \r\n    to: function() { \r\n      return Position.max(this.anchor, this.head); \r\n    },\r\n    \r\n    empty: function() {\r\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\r\n    },\r\n\r\n    extend : function extendRange(head, other, extend) {\r\n      // moved from model/selection_updates.js\r\n        if (extend) {\r\n          let anchor = this.anchor;\r\n          if (other) {\r\n              let posBefore = Position.compare(head, anchor) < 0;\r\n              if (posBefore != Position.compare(other, anchor) < 0) {\r\n                  anchor = head;\r\n                  head = other;\r\n              } else if (posBefore != Position.compare(head, other) < 0) {\r\n                  head = other;\r\n              }\r\n          }\r\n          return new Range(anchor, head);\r\n        } else {\r\n          return new Range(other || head, head);\r\n        }\r\n    }\r\n  });\r\n\r\n  return plain.Range = Range;\r\n\r\n});\r\n\ndefine('skylark-texts-plain/selection',[\r\n  \"skylark-langx/klass\",\r\n  \"./plain\",\r\n  \"./position\",\r\n  \"./range\"\r\n],function(klass,plain, Position, Range) {\r\n\r\n  // Original: model/selection.js\r\n\r\n  var Selection = klass({\r\n    klassName : \"Selection\",\r\n\r\n    _construct : function (ranges, primIndex) {\r\n      this.ranges = ranges;\r\n      this.primIndex = primIndex;\r\n    },\r\n    \r\n    primary: function() { \r\n      return this.ranges[this.primIndex]; \r\n    },\r\n    \r\n    equals: function(other) {\r\n      if (other == this) return true;\r\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\r\n      for (var i = 0; i < this.ranges.length; i++) {\r\n        var here = this.ranges[i], there = other.ranges[i];\r\n        if (Position.compare(here.anchor, there.anchor) != 0 || Position.compare(here.head, there.head) != 0) return false;\r\n      }\r\n      return true;\r\n    },\r\n    \r\n    deepCopy: function() {\r\n      for (var out = [], i = 0; i < this.ranges.length; i++)\r\n        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\r\n      return new Selection(out, this.primIndex);\r\n    },\r\n    \r\n    somethingSelected: function() {\r\n      for (var i = 0; i < this.ranges.length; i++)\r\n        if (!this.ranges[i].empty()) return true;\r\n      return false;\r\n    },\r\n    \r\n    contains: function(pos, end) {\r\n      if (!end) end = pos;\r\n      for (var i = 0; i < this.ranges.length; i++) {\r\n        var range = this.ranges[i];\r\n        if (Position.compare(end, range.from()) >= 0 && Position.compare(pos, range.to()) <= 0)\r\n          return i;\r\n      }\r\n      return -1;\r\n    }\r\n\r\n  });\r\n\r\n  // Take an unsorted, potentially overlapping set of ranges, and\r\n  // build a selection out of it. 'Consumes' ranges array (modifying\r\n  // it).\r\n\r\n  Selection.normalize =  function normalizeSelection(mayTouch, ranges, primIndex) {\r\n      //let mayTouch = cm && cm.options.selectionsMayTouch;\r\n      let prim = ranges[primIndex];\r\n      ranges.sort((a, b) => Position.compare(a.from(), b.from()));\r\n      primIndex = arrays.indexOf(ranges, prim);\r\n      for (let i = 1; i < ranges.length; i++) {\r\n          let cur = ranges[i], prev = ranges[i - 1];\r\n          let diff = Position.compare(prev.to(), cur.from());\r\n          if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\r\n              let from = Position.min(prev.from(), cur.from()), to = Position.max(prev.to(), cur.to());\r\n              let inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\r\n              if (i <= primIndex)\r\n                  --primIndex;\r\n              ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\r\n          }\r\n      }\r\n      return new Selection(ranges, primIndex);\r\n  };\r\n\r\n  Selection.simple =  function simpleSelection(anchor, head) {\r\n    return new Selection([new Range(anchor, head || anchor)], 0);\r\n  };\r\n\r\n  return plain.Selection = Selection;\r\n});\n define('skylark-texts-plain/line',[\r\n  \"skylark-langx/Evented\",\r\n  \"./plain\"\r\n],function(Evented,plain){\r\n\r\n  // LINE DATA STRUCTURE\r\n\r\n  // Line objects. These hold state related to a line, including\r\n  // highlighting info (the styles array).\r\n  var Line = Evented.inherit({\r\n    _construct : function(text, markedSpans, estimateHeight) {\r\n      this.text = text;\r\n      //TODO : The following logic will been changing\r\n      if (this.attachMarkedSpans) {\r\n        this.attachMarkedSpans(markedSpans);      \r\n      }\r\n      if (this.updateLineHeight) {\r\n        this.height = estimateHeight ? estimateHeight(this) : 1;\r\n      }\r\n    },\r\n\r\n    lineNo : function() { \r\n      //return lineNo(this); \r\n      var line = this;\r\n      if (line.parent == null) {\r\n        return null;\r\n      }\r\n      var cur = line.parent, no = indexOf(cur.lines, line);\r\n      for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\r\n        for (var i = 0;; ++i) {\r\n          if (chunk.children[i] == cur) break;\r\n          no += chunk.children[i].chunkSize();\r\n        }\r\n      }\r\n      return no + cur.first;\r\n    },\r\n\r\n    // Change the content (text, markers) of a line. Automatically\r\n    // invalidates cached information and tries to re-estimate the\r\n    // line's height.\r\n    updateLine : function (text, markedSpans, estimateHeight) {\r\n      var line = this;\r\n\r\n      line.text = text;\r\n      if (line.stateAfter) line.stateAfter = null;\r\n      if (line.styles) line.styles = null;\r\n      if (line.order != null) line.order = null;\r\n\r\n\r\n      //TODO : The following logic will been changing\r\n\r\n      if (this.detachMarkedSpans) {\r\n        line.detachMarkedSpans();\r\n      }\r\n      if (this.attachMarkedSpans) {\r\n        line.attachMarkedSpans( markedSpans);\r\n      }\r\n      if (this.updateLineHeight) {\r\n        var estHeight = estimateHeight ? estimateHeight(line) : 1;\r\n        if (estHeight != line.height) line.updateLineHeight(estHeight);\r\n      }\r\n    },\r\n\r\n    // Detach a line from the document tree and its markers.\r\n    cleanUpLine : function () {\r\n      var line = this;\r\n      line.parent = null;\r\n\r\n      //TODO : The following logic will been changing\r\n      if (this.detachMarkedSpans) {\r\n        line.detachMarkedSpans();\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n\r\n  function extractLineClasses(type, output) {\r\n    if (type) for (;;) {\r\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\r\n      if (!lineClass) break;\r\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\r\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\r\n      if (output[prop] == null)\r\n        output[prop] = lineClass[2];\r\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\r\n        output[prop] += \" \" + lineClass[2];\r\n    }\r\n    return type;\r\n  }\r\n\r\n  function callBlankLine(mode, state) {\r\n    if (mode.blankLine) return mode.blankLine(state);\r\n    if (!mode.innerMode) return;\r\n    var inner = CodeMirror.innerMode(mode, state);\r\n    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\r\n  }\r\n\r\n  // Counts the column offset in a string, taking tabs into account.\r\n  // Used mostly to find indentation.\r\n  var countColumn = Line.countColumn = function(string, end, tabSize, startIndex, startValue) {\r\n    if (end == null) {\r\n      end = string.search(/[^\\s\\u00a0]/);\r\n      if (end == -1) end = string.length;\r\n    }\r\n    for (var i = startIndex || 0, n = startValue || 0;;) {\r\n      var nextTab = string.indexOf(\"\\t\", i);\r\n      if (nextTab < 0 || nextTab >= end)\r\n        return n + (end - i);\r\n      n += nextTab - i;\r\n      n += tabSize - (n % tabSize);\r\n      i = nextTab + 1;\r\n    }\r\n  };\r\n\r\n  // The inverse of countColumn -- find the offset that corresponds to\r\n  // a particular column.\r\n  var findColumn = Line.findColumn = function(string, goal, tabSize) {\r\n    for (var pos = 0, col = 0;;) {\r\n      var nextTab = string.indexOf(\"\\t\", pos);\r\n      if (nextTab == -1) nextTab = string.length;\r\n      var skipped = nextTab - pos;\r\n      if (nextTab == string.length || col + skipped >= goal)\r\n        return pos + Math.min(skipped, goal - col);\r\n      col += nextTab - pos;\r\n      col += tabSize - (col % tabSize);\r\n      pos = nextTab + 1;\r\n      if (col >= goal) return pos;\r\n    }\r\n  }\r\n\r\n  return plain.Line = Line;\r\n\r\n});\r\n\r\n\ndefine('skylark-texts-plain/leaf_chunk',[\r\n  \"skylark-langx/Evented\",\r\n  \"./plain\"\r\n],function(Evented,plain){\r\n  // Original: model/chunk.js\r\n\r\n  var LeafChunk = Evented.inherit({\r\n    klassName : \"LeafChunk\",\r\n\r\n    _construct :  function(lines) {\r\n      this.lines = lines;\r\n      this.parent = null;\r\n      for (var i = 0, height = 0; i < lines.length; ++i) {\r\n        lines[i].parent = this;\r\n        height += lines[i].height;\r\n      }\r\n      this.height = height;\r\n    },\r\n\r\n    chunkSize: function() { \r\n      return this.lines.length; \r\n    },\r\n    \r\n    // Remove the n lines at offset 'at'.\r\n    removeInner: function(at, n) {\r\n      for (var i = at, e = at + n; i < e; ++i) {\r\n        var line = this.lines[i];\r\n        this.height -= line.height;\r\n        line.cleanUpLine();\r\n        //signalLater(line, \"delete\");\r\n        this.emit(\"delete\",line)\r\n      }\r\n      this.lines.splice(at, n);\r\n    },\r\n\r\n    // Helper used to collapse a small branch into a single leaf.\r\n    collapse: function(lines) {\r\n      lines.push.apply(lines, this.lines);\r\n    },\r\n\r\n    // Insert the given array of lines at offset 'at', count them as\r\n    // having the given height.\r\n    insertInner: function(at, lines, height) {\r\n      this.height += height;\r\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\r\n      for (var i = 0; i < lines.length; ++i) {\r\n        lines[i].parent = this;\r\n      }\r\n    },\r\n\r\n    // Used to iterate over a part of the tree.\r\n    iterN: function(at, n, op) {\r\n      for (var e = at + n; at < e; ++at)\r\n        if (op(this.lines[at])) {\r\n          return true;\r\n        }\r\n    }\r\n  });\r\n\r\n  return  plain.LeafChunk = LeafChunk;\r\n\r\n});\ndefine('skylark-texts-plain/branch_chunk',[\r\n  \"skylark-langx/Evented\",\r\n  \"./plain\",\r\n  \"./leaf_chunk\"\r\n],function(Evented,plain,LeafChunk){\r\n  // Original: model/chunk.js\r\n\r\n  var BranchChunk = Evented.inherit({\r\n    klassName : \"BranchChunk\",\r\n\r\n    _construct : function (children) {\r\n      this.children = children;\r\n      var size = 0, height = 0;\r\n      for (var i = 0; i < children.length; ++i) {\r\n        var ch = children[i];\r\n        size += ch.chunkSize(); height += ch.height;\r\n        ch.parent = this;\r\n      }\r\n      this.size = size;\r\n      this.height = height;\r\n      this.parent = null;\r\n    },\r\n\r\n    chunkSize: function() { \r\n      return this.size; \r\n    },\r\n    \r\n    removeInner: function(at, n) {\r\n      this.size -= n;\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at < sz) {\r\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\r\n          child.removeInner(at, rm);\r\n          this.height -= oldHeight - child.height;\r\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\r\n          if ((n -= rm) == 0) break;\r\n          at = 0;\r\n        } else at -= sz;\r\n      }\r\n      // If the result is smaller than 25 lines, ensure that it is a\r\n      // single leaf node.\r\n      if (this.size - n < 25 &&\r\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\r\n        var lines = [];\r\n        this.collapse(lines);\r\n        this.children = [new LeafChunk(lines)];\r\n        this.children[0].parent = this;\r\n      }\r\n    },\r\n\r\n    collapse: function(lines) {\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        this.children[i].collapse(lines);\r\n      }\r\n    },\r\n\r\n    insertInner: function(at, lines, height) {\r\n      this.size += lines.length;\r\n      this.height += height;\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at <= sz) {\r\n          child.insertInner(at, lines, height);\r\n          if (child.lines && child.lines.length > 50) {\r\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\r\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\r\n            var remaining = child.lines.length % 25 + 25\r\n            for (var pos = remaining; pos < child.lines.length;) {\r\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\r\n              child.height -= leaf.height;\r\n              this.children.splice(++i, 0, leaf);\r\n              leaf.parent = this;\r\n            }\r\n            child.lines = child.lines.slice(0, remaining);\r\n            this.maybeSpill();\r\n          }\r\n          break;\r\n        }\r\n        at -= sz;\r\n      }\r\n    },\r\n    // When a node has grown, check whether it should be split.\r\n    maybeSpill: function() {\r\n      if (this.children.length <= 10) return;\r\n      var me = this;\r\n      do {\r\n        var spilled = me.children.splice(me.children.length - 5, 5);\r\n        var sibling = new BranchChunk(spilled);\r\n        if (!me.parent) { // Become the parent node\r\n          var copy = new BranchChunk(me.children);\r\n          copy.parent = me;\r\n          me.children = [copy, sibling];\r\n          me = copy;\r\n       } else {\r\n          me.size -= sibling.size;\r\n          me.height -= sibling.height;\r\n          var myIndex = indexOf(me.parent.children, me);\r\n          me.parent.children.splice(myIndex + 1, 0, sibling);\r\n        }\r\n        sibling.parent = me.parent;\r\n      } while (me.children.length > 10);\r\n      me.parent.maybeSpill();\r\n    },\r\n    \r\n    iterN: function(at, n, op) {\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at < sz) {\r\n          var used = Math.min(n, sz - at);\r\n          if (child.iterN(at, used, op)) return true;\r\n          if ((n -= used) == 0) break;\r\n          at = 0;\r\n        } else at -= sz;\r\n      }\r\n    }\r\n  });\r\n\r\n  return plain.BranchChunk = BranchChunk;\r\n});\r\n\ndefine('skylark-texts-plain/history',[\r\n    \"skylark-langx-arrays\",\r\n    './position',\r\n    './selection'\r\n], function (arrays,Position,  Selection) {\r\n    'use strict';\r\n\r\n    //TODO:spans/change_measurement/document_data\r\n\r\n    function History(startGen) {\r\n        this.done = [];\r\n        this.undone = [];\r\n        this.undoDepth = Infinity;\r\n        this.lastModTime = this.lastSelTime = 0;\r\n        this.lastOp = this.lastSelOp = null;\r\n        this.lastOrigin = this.lastSelOrigin = null;\r\n        this.generation = this.maxGeneration = startGen || 1;\r\n    }\r\n\r\n    function historyChangeFromChange(doc, change) {\r\n        let histChange = {\r\n            from: Position.copy(change.from),\r\n            to: change_measurement.changeEnd(change),\r\n            text: doc.getBetween(change.from, change.to)\r\n        };\r\n        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\r\n        document_data.linkedDocs(doc, doc => attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1), true);\r\n        return histChange;\r\n    }\r\n\r\n    function clearSelectionEvents(array) {\r\n        while (array.length) {\r\n            let last = arrays.last(array);\r\n            if (last.ranges)\r\n                array.pop();\r\n            else\r\n                break;\r\n        }\r\n    }\r\n\r\n    function lastChangeEvent(hist, force) {\r\n        if (force) {\r\n            clearSelectionEvents(hist.done);\r\n            return arrays.last(hist.done);\r\n        } else if (hist.done.length && !arrays.last(hist.done).ranges) {\r\n            return arrays.last(hist.done);\r\n        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\r\n            hist.done.pop();\r\n            return arrays.last(hist.done);\r\n        }\r\n    }\r\n    function addChangeToHistory(doc, change, selAfter, opId) {\r\n        let hist = doc.history;\r\n        hist.undone.length = 0;\r\n        let time = +new Date(), cur;\r\n        let last;\r\n        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == '*')) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\r\n            last = arrays.last(cur.changes);\r\n            if (Position.compare(change.from, change.to) == 0 && Position.compare(change.from, last.to) == 0) {\r\n                last.to = change_measurement.changeEnd(change);\r\n            } else {\r\n                cur.changes.push(historyChangeFromChange(doc, change));\r\n            }\r\n        } else {\r\n            let before = arrays.last(hist.done);\r\n            if (!before || !before.ranges)\r\n                pushSelectionToHistory(doc.sel, hist.done);\r\n            cur = {\r\n                changes: [historyChangeFromChange(doc, change)],\r\n                generation: hist.generation\r\n            };\r\n            hist.done.push(cur);\r\n            while (hist.done.length > hist.undoDepth) {\r\n                hist.done.shift();\r\n                if (!hist.done[0].ranges)\r\n                    hist.done.shift();\r\n            }\r\n        }\r\n        hist.done.push(selAfter);\r\n        hist.generation = ++hist.maxGeneration;\r\n        hist.lastModTime = hist.lastSelTime = time;\r\n        hist.lastOp = hist.lastSelOp = opId;\r\n        hist.lastOrigin = hist.lastSelOrigin = change.origin;\r\n        if (!last)\r\n            doc.emit('historyAdded');\r\n    }\r\n\r\n    function selectionEventCanBeMerged(doc, origin, prev, sel) {\r\n        let ch = origin.charAt(0);\r\n        return ch == '*' || ch == '+' && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\r\n    }\r\n\r\n    function addSelectionToHistory(doc, sel, opId, options) {\r\n        let hist = doc.history, origin = options && options.origin;\r\n        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, arrays.last(hist.done), sel)))\r\n            hist.done[hist.done.length - 1] = sel;\r\n        else\r\n            pushSelectionToHistory(sel, hist.done);\r\n        hist.lastSelTime = +new Date();\r\n        hist.lastSelOrigin = origin;\r\n        hist.lastSelOp = opId;\r\n        if (options && options.clearRedo !== false)\r\n            clearSelectionEvents(hist.undone);\r\n    }\r\n\r\n    function pushSelectionToHistory(sel, dest) {\r\n        let top = arrays.last(dest);\r\n        if (!(top && top.ranges && top.equals(sel)))\r\n            dest.push(sel);\r\n    }\r\n\r\n    function attachLocalSpans(doc, change, from, to) {\r\n        let existing = change['spans_' + doc.id], n = 0;\r\n        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), line => {\r\n            if (line.markedSpans)\r\n                (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;\r\n            ++n;\r\n        });\r\n    }\r\n\r\n    function removeClearedSpans(spans) {\r\n        if (!spans)\r\n            return null;\r\n        let out;\r\n        for (let i = 0; i < spans.length; ++i) {\r\n            if (spans[i].marker.explicitlyCleared) {\r\n                if (!out)\r\n                    out = spans.slice(0, i);\r\n            } else if (out)\r\n                out.push(spans[i]);\r\n        }\r\n        return !out ? spans : out.length ? out : null;\r\n    }\r\n\r\n    function getOldSpans(doc, change) {\r\n        let found = change['spans_' + doc.id];\r\n        if (!found)\r\n            return null;\r\n        let nw = [];\r\n        for (let i = 0; i < change.text.length; ++i)\r\n            nw.push(removeClearedSpans(found[i]));\r\n        return nw;\r\n    }\r\n\r\n    function mergeOldSpans(doc, change) {\r\n        let old = getOldSpans(doc, change);\r\n        let stretched = spans.stretchSpansOverChange(doc, change);\r\n        if (!old)\r\n            return stretched;\r\n        if (!stretched)\r\n            return old;\r\n        for (let i = 0; i < old.length; ++i) {\r\n            let oldCur = old[i], stretchCur = stretched[i];\r\n            if (oldCur && stretchCur) {\r\n                spans:\r\n                    for (let j = 0; j < stretchCur.length; ++j) {\r\n                        let span = stretchCur[j];\r\n                        for (let k = 0; k < oldCur.length; ++k)\r\n                            if (oldCur[k].marker == span.marker)\r\n                                continue spans;\r\n                        oldCur.push(span);\r\n                    }\r\n            } else if (stretchCur) {\r\n                old[i] = stretchCur;\r\n            }\r\n        }\r\n        return old;\r\n    }\r\n\r\n    function copyHistoryArray(events, newGroup, instantiateSel) {\r\n        let copy = [];\r\n        for (let i = 0; i < events.length; ++i) {\r\n            let event = events[i];\r\n            if (event.ranges) {\r\n                copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\r\n                continue;\r\n            }\r\n            let changes = event.changes, newChanges = [];\r\n            copy.push({ changes: newChanges });\r\n            for (let j = 0; j < changes.length; ++j) {\r\n                let change = changes[j], m;\r\n                newChanges.push({\r\n                    from: change.from,\r\n                    to: change.to,\r\n                    text: change.text\r\n                });\r\n                if (newGroup)\r\n                    for (var prop in change)\r\n                        if (m = prop.match(/^spans_(\\d+)$/)) {\r\n                            if (arrays.indexOf(newGroup, Number(m[1])) > -1) {\r\n                                arrays.last(newChanges)[prop] = change[prop];\r\n                                delete change[prop];\r\n                            }\r\n                        }\r\n            }\r\n        }\r\n        return copy;\r\n    }\r\n\r\n    History.historyChangeFromChange = historyChangeFromChange;\r\n    History.addChangeToHistory = addChangeToHistory;\r\n    History.addSelectionToHistory = addSelectionToHistory;\r\n    History.pushSelectionToHistory = pushSelectionToHistory;\r\n    History.mergeOldSpans = mergeOldSpans;\r\n    History.copyHistoryArray = copyHistoryArray;\r\n\r\n    return History;\r\n});\ndefine('skylark-texts-plain/document',[\r\n  \"skylark-langx/arrays\",\r\n  \"skylark-langx/Evented\",\r\n  \"./plain\",\r\n  \"./branch_chunk\",\r\n  \"./leaf_chunk\",\r\n  \"./position\",\r\n  \"./selection\",\r\n  \"./history\"\r\n],function(arrays, Evented,plain,BranchChunk,LeafChunk,Position,Selection, History){\r\n    // Original : model/doc.js \r\n    //TODO : selection_updates/history/marker\r\n    'use strict';\r\n    let nextDocId = 0;\r\n\r\n  // The document is represented as a BTree consisting of leaves, with\r\n  // chunk of lines in them, and branches, with up to ten leaves or\r\n  // other branch nodes below them. The top node is always a branch\r\n  // node, and is the document object itself (meaning it has\r\n  // additional methods and properties).\r\n  //\r\n  // All nodes have parent links. The tree is used both to go from\r\n  // line numbers to line objects, and to go from objects to numbers.\r\n  // It also indexes by height, and is used to convert between height\r\n  // and line object, and to find the total height of the document.\r\n  //\r\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\r\n  \r\n  var Document = BranchChunk.inherit({\r\n\r\n    _construct : function(text, mode, firstLine, lineSep,direction) {\r\n      if (firstLine == null) firstLine = 0;\r\n\r\n      thie.overrited(new LeafChunk([new Line(\"\", null)]));\r\n\r\n      this.first = firstLine;\r\n      this.scrollTop = this.scrollLeft = 0;\r\n      this.cantEdit = false;\r\n      this.cleanGeneration = 1;\r\n      this.modeFrontier = this.highlightFrontier = firstLine;\r\n      let start = new Position(firstLine, 0);\r\n      this.sel = Selection.simple(start);\r\n      this.history = new m_history.History(null);\r\n      this.id = ++nextDocId;\r\n      this.modeOption = mode;\r\n      this.lineSep = lineSep;\r\n      this.direction = direction == 'rtl' ? 'rtl' : 'ltr';\r\n      this.extend = false;\r\n      if (typeof text == 'string') {\r\n          text = this.splitLines(text);\r\n      }\r\n      document_data.updateDoc(this, {\r\n          from: start,\r\n          to: start,\r\n          text: text\r\n      });\r\n      selection_updates.setSelection(this, Selection.simple(start), misc.sel_dontScroll);\r\n    },\r\n\r\n    iter: function (from, to, op) {\r\n        if (op) {\r\n          this.iterN(from - this.first, to - from, op);\r\n        } else {\r\n          this.iterN(this.first, this.first + this.size, from);\r\n        }\r\n    },\r\n\r\n    insert: function (at, lines) {\r\n        let height = 0;\r\n        for (let i = 0; i < lines.length; ++i) {\r\n            height += lines[i].height;\r\n        }\r\n        this.insertInner(at - this.first, lines, height);\r\n    },\r\n\r\n    remove: function (at, n) {\r\n        this.removeInner(at - this.first, n);\r\n    },\r\n\r\n    getValue: function (lineSep) {\r\n        let lines = this.getLines(this.first, this.first + this.size);\r\n        if (lineSep === false)\r\n            return lines;\r\n        return lines.join(lineSep || this.lineSeparator());\r\n    },\r\n\r\n    setValue: function (code) {\r\n        //operations.docMethodOp\r\n        let top = new Position(this.first, 0), last = this.first + this.size - 1;\r\n        changes.makeChange(this, {\r\n            from: top,\r\n            to: new Position(last, this.getLineHandle(last).text.length),\r\n            text: this.splitLines(code),\r\n            origin: 'setValue',\r\n            full: true\r\n        }, true);\r\n        if (this.cm)\r\n            scrolling.scrollToCoords(this.cm, 0, 0);\r\n        selection_updates.setSelection(this, Selection.simple(top), misc.sel_dontScroll);\r\n    },\r\n\r\n    replaceRange: function (code, from, to, origin) {\r\n        from = this.clipPos( from);\r\n        to = to ? this.clipPos( to) : from;\r\n        changes.replaceRange(this, code, from, to, origin);\r\n    },\r\n\r\n    getRange: function (from, to, lineSep) {\r\n        let lines = this.getBetween(this.clipPos( from), this.clipPos( to));\r\n        if (lineSep === false)\r\n            return lines;\r\n        return lines.join(lineSep || this.lineSeparator());\r\n    },\r\n\r\n    getBetween : function (start, end) {\r\n        // moved from line/utils_line.js\r\n        let doc = this,\r\n            out = [], n = start.line;\r\n        doc.iter(start.line, end.line + 1, line => {\r\n            let text = line.text;\r\n            if (n == end.line)\r\n                text = text.slice(0, end.ch);\r\n            if (n == start.line)\r\n                text = text.slice(start.ch);\r\n            out.push(text);\r\n            ++n;\r\n        });\r\n        return out;\r\n    },\r\n\r\n    getLine: function (line) {\r\n        let l = this.getLineHandle(line);\r\n        return l && l.text;\r\n    },\r\n\r\n    getLines : function (from, to) {\r\n        // moved from line/utils_line.js\r\n        let doc = this,\r\n            out = [];\r\n        doc.iter(from, to, line => {\r\n            out.push(line.text);\r\n        });\r\n        return out;\r\n    },\r\n\r\n    getLineHandle: function (n) {\r\n        ///return utils_line.getLine(this, n);\r\n\r\n        // moved from line/utils_line.js\r\n        n -= this.first;\r\n        if (n < 0 || n >= this.size)\r\n            throw new Error('There is no line ' + (n + this.first) + ' in the document.');\r\n        let chunk = this;\r\n        while (!chunk.lines) {\r\n            for (let i = 0;; ++i) {\r\n                let child = chunk.children[i], sz = child.chunkSize();\r\n                if (n < sz) {\r\n                    chunk = child;\r\n                    break;\r\n                }\r\n                n -= sz;\r\n            }\r\n        }\r\n        return chunk.lines[n];\r\n    },\r\n\r\n    getLineNumber: function (line) {\r\n        ///return utils_line.lineNo(line);\r\n        // moved from line/utils_line.js\r\n        if (line.parent == null)\r\n            return null;\r\n        let cur = line.parent, no = arrays.indexOf(cur.lines, line);\r\n        for (let chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\r\n            for (let i = 0;; ++i) {\r\n                if (chunk.children[i] == cur)\r\n                    break;\r\n                no += chunk.children[i].chunkSize();\r\n            }\r\n        }\r\n        return no + cur.first;\r\n    },\r\n\r\n    getLineHandleVisualStart: function (line) {\r\n        if (typeof line == 'number')\r\n            line = this.getLineHandle(line);\r\n        return spans.visualLine(line);\r\n    },\r\n\r\n    isLine : function(l) {\r\n        // moved from line/utils_line.js\r\n        return l >= this.first && l < this.first + this.size;        \r\n    },\r\n\r\n    lineCount: function () {\r\n        return this.size;\r\n    },\r\n\r\n    firstLine: function () {\r\n        return this.first;\r\n    },\r\n\r\n    lastLine: function () {\r\n        return this.first + this.size - 1;\r\n    },\r\n\r\n    clipPos: function (pos) {\r\n        ///return m_pos.clipPos(this, pos);\r\n        //moved from line/pos.js\r\n        if (pos.line < this.first)\r\n            return  new Position(this.first, 0);\r\n        let last = this.first + this.size - 1;\r\n        if (pos.line > last)\r\n            return Position(last, this.getLineHandle(last).text.length);\r\n        return pos.clipToLen(this.getLineHandle(pos.line).text.length);\r\n    },\r\n\r\n    getCursor: function (start) {\r\n        let range = this.sel.primary(), pos;\r\n        if (start == null || start == 'head')\r\n            pos = range.head;\r\n        else if (start == 'anchor')\r\n            pos = range.anchor;\r\n        else if (start == 'end' || start == 'to' || start === false)\r\n            pos = range.to();\r\n        else\r\n            pos = range.from();\r\n        return pos;\r\n    },\r\n\r\n    listSelections: function () {\r\n        return this.sel.ranges;\r\n    },\r\n\r\n    somethingSelected: function () {\r\n        return this.sel.somethingSelected();\r\n    },\r\n\r\n\r\n    setCursor: function (line, ch, options) {\r\n        //operations.docMethodOp\r\n        selection_updates.setSimpleSelection(this, this.clipPos( typeof line == 'number' ? new Position(line, ch || 0) : line), null, options);\r\n    },\r\n\r\n    setSelection: function (anchor, head, options) {\r\n        //operations.docMethodOp\r\n        selection_updates.setSimpleSelection(this, this.clipPos( anchor), this.clipPos( head || anchor), options);\r\n    },\r\n\r\n    extendSelection: function (head, other, options) {\r\n        //operations.docMethodOp\r\n        selection_updates.extendSelection(this, this.clipPos( head), other && this.clipPos( other), options);\r\n    },\r\n\r\n    extendSelections: function (heads, options) {\r\n        //operations.docMethodOp\r\n        selection_updates.extendSelections(this, m_pos.clipPosArray(this, heads), options);\r\n    },\r\n\r\n    extendSelectionsBy: function (f, options) {\r\n        //operations.docMethodOp\r\n        let heads = misc.map(this.sel.ranges, f);\r\n        selection_updates.extendSelections(this, m_pos.clipPosArray(this, heads), options);\r\n    },\r\n\r\n    setSelections: function (ranges, primary, options) {\r\n        //operations.docMethodOp\r\n        if (!ranges.length)\r\n            return;\r\n        let out = [];\r\n        for (let i = 0; i < ranges.length; i++)\r\n            out[i] = new m_selection.Range(this.clipPos( ranges[i].anchor), this.clipPos( ranges[i].head));\r\n        if (primary == null)\r\n            primary = Math.min(ranges.length - 1, this.sel.primIndex);\r\n        selection_updates.setSelection(this, Selection.normalize(this.cm, out, primary), options);\r\n    },\r\n\r\n    addSelection: function (anchor, head, options) {\r\n        //operations.docMethodOp\r\n        let ranges = this.sel.ranges.slice(0);\r\n        ranges.push(new m_selection.Range(this.clipPos( anchor), this.clipPos( head || anchor)));\r\n        selection_updates.setSelection(this, m_selection.normalizeSelection(this.cm, ranges, ranges.length - 1), options);\r\n    },\r\n\r\n    getSelection: function (lineSep) {\r\n        let ranges = this.sel.ranges, lines;\r\n        for (let i = 0; i < ranges.length; i++) {\r\n            let sel = this.getBetween(ranges[i].from(), ranges[i].to());\r\n            lines = lines ? lines.concat(sel) : sel;\r\n        }\r\n        if (lineSep === false)\r\n            return lines;\r\n        else\r\n            return lines.join(lineSep || this.lineSeparator());\r\n    },\r\n    getSelections: function (lineSep) {\r\n        let parts = [], ranges = this.sel.ranges;\r\n        for (let i = 0; i < ranges.length; i++) {\r\n            let sel = this.getBetween(ranges[i].from(), ranges[i].to());\r\n            if (lineSep !== false)\r\n                sel = sel.join(lineSep || this.lineSeparator());\r\n            parts[i] = sel;\r\n        }\r\n        return parts;\r\n    },\r\n    replaceSelection: function (code, collapse, origin) {\r\n        let dup = [];\r\n        for (let i = 0; i < this.sel.ranges.length; i++)\r\n            dup[i] = code;\r\n        this.replaceSelections(dup, collapse, origin || '+input');\r\n    },\r\n\r\n    replaceSelections: function (code, collapse, origin) {\r\n        //operations.docMethodOp\r\n        let changes = [], sel = this.sel;\r\n        for (let i = 0; i < sel.ranges.length; i++) {\r\n            let range = sel.ranges[i];\r\n            changes[i] = {\r\n                from: range.from(),\r\n                to: range.to(),\r\n                text: this.splitLines(code[i]),\r\n                origin: origin\r\n            };\r\n        }\r\n        let newSel = collapse && collapse != 'end' && change_measurement.computeReplacedSel(this, changes, collapse);\r\n        for (let i = changes.length - 1; i >= 0; i--)\r\n            changes.makeChange(this, changes[i]);\r\n        if (newSel)\r\n            selection_updates.setSelectionReplaceHistory(this, newSel);\r\n        else if (this.cm)\r\n            scrolling.ensureCursorVisible(this.cm);\r\n    },\r\n\r\n    undo: function () {\r\n        //operations.docMethodOp\r\n        changes.makeChangeFromHistory(this, 'undo');\r\n    },\r\n\r\n    redo: function () {\r\n        //operations.docMethodOp\r\n        changes.makeChangeFromHistory(this, 'redo');\r\n    },\r\n\r\n    undoSelection: function () {\r\n        //operations.docMethodOp\r\n        changes.makeChangeFromHistory(this, 'undo', true);\r\n    },\r\n\r\n    redoSelection: function () {\r\n        //operations.docMethodOp\r\n        changes.makeChangeFromHistory(this, 'redo', true);\r\n    },\r\n\r\n    setExtending: function (val) {\r\n        this.extend = val;\r\n    },\r\n\r\n    getExtending: function () {\r\n        return this.extend;\r\n    },\r\n\r\n    historySize: function () {\r\n        let hist = this.history, done = 0, undone = 0;\r\n        for (let i = 0; i < hist.done.length; i++)\r\n            if (!hist.done[i].ranges)\r\n                ++done;\r\n        for (let i = 0; i < hist.undone.length; i++)\r\n            if (!hist.undone[i].ranges)\r\n                ++undone;\r\n        return {\r\n            undo: done,\r\n            redo: undone\r\n        };\r\n    },\r\n\r\n    clearHistory: function () {\r\n        this.history = new m_history.History(this.history.maxGeneration);\r\n    },\r\n\r\n    markClean: function () {\r\n        this.cleanGeneration = this.changeGeneration(true);\r\n    },\r\n\r\n    changeGeneration: function (forceSplit) {\r\n        if (forceSplit)\r\n            this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\r\n        return this.history.generation;\r\n    },\r\n\r\n    isClean: function (gen) {\r\n        return this.history.generation == (gen || this.cleanGeneration);\r\n    },\r\n\r\n    getHistory: function () {\r\n        return {\r\n            done: m_history.copyHistoryArray(this.history.done),\r\n            undone: m_history.copyHistoryArray(this.history.undone)\r\n        };\r\n    },\r\n\r\n    setHistory: function (histData) {\r\n        let hist = this.history = new m_history.History(this.history.maxGeneration);\r\n        hist.done = m_history.copyHistoryArray(histData.done.slice(0), null, true);\r\n        hist.undone = m_history.copyHistoryArray(histData.undone.slice(0), null, true);\r\n    },\r\n\r\n    setGutterMarker: function (line, gutterID, value) {\r\n        //operations.docMethodOp\r\n        return changes.changeLine(this, line, 'gutter', line => {\r\n            let markers = line.gutterMarkers || (line.gutterMarkers = {});\r\n            markers[gutterID] = value;\r\n            if (!value && misc.isEmpty(markers))\r\n                line.gutterMarkers = null;\r\n            return true;\r\n        });\r\n    },\r\n\r\n    clearGutter: function (gutterID) {\r\n        //operations.docMethodOp\r\n        this.iter(line => {\r\n            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\r\n                changes.changeLine(this, line, 'gutter', () => {\r\n                    line.gutterMarkers[gutterID] = null;\r\n                    if (misc.isEmpty(line.gutterMarkers))\r\n                        line.gutterMarkers = null;\r\n                    return true;\r\n                });\r\n            }\r\n        });\r\n    },\r\n\r\n    lineInfo: function (line) {\r\n        let n;\r\n        if (typeof line == 'number') {\r\n            if (!this.isLine(line))\r\n                return null;\r\n            n = line;\r\n            line = this.getLineHandle(line);\r\n            if (!line)\r\n                return null;\r\n        } else {\r\n            n = this.getLineNumber(line);\r\n            if (n == null)\r\n                return null;\r\n        }\r\n        return {\r\n            line: n,\r\n            handle: line,\r\n            text: line.text,\r\n            gutterMarkers: line.gutterMarkers,\r\n            textClass: line.textClass,\r\n            bgClass: line.bgClass,\r\n            wrapClass: line.wrapClass,\r\n            widgets: line.widgets\r\n        };\r\n    },\r\n\r\n    addLineClass: function (handle, where, cls) {\r\n        //operations.docMethodOp\r\n        return changes.changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', line => {\r\n            let prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';\r\n            if (!line[prop])\r\n                line[prop] = cls;\r\n            else if (dom.classTest(cls).test(line[prop]))\r\n                return false;\r\n            else\r\n                line[prop] += ' ' + cls;\r\n            return true;\r\n        });\r\n    },\r\n\r\n    removeLineClass: function (handle, where, cls) {\r\n        //operations.docMethodOp\r\n        return changes.changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', line => {\r\n            let prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';\r\n            let cur = line[prop];\r\n            if (!cur)\r\n                return false;\r\n            else if (cls == null)\r\n                line[prop] = null;\r\n            else {\r\n                let found = cur.match(dom.classTest(cls));\r\n                if (!found)\r\n                    return false;\r\n                let end = found.index + found[0].length;\r\n                line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? '' : ' ') + cur.slice(end) || null;\r\n            }\r\n            return true;\r\n        });\r\n    },\r\n\r\n    addLineWidget: function (handle, node, options) {\r\n        //operations.docMethodOp\r\n        return line_widget.addLineWidget(this, handle, node, options);\r\n    },\r\n\r\n    removeLineWidget: function (widget) {\r\n        widget.clear();\r\n    },\r\n\r\n    markText: function (from, to, options) {\r\n        return mark_text.markText(this, this.clipPos( from), this.clipPos( to), options, options && options.type || 'range');\r\n    },\r\n\r\n    setBookmark: function (pos, options) {\r\n        let realOpts = {\r\n            replacedWith: options && (options.nodeType == null ? options.widget : options),\r\n            insertLeft: options && options.insertLeft,\r\n            clearWhenEmpty: false,\r\n            shared: options && options.shared,\r\n            handleMouseEvents: options && options.handleMouseEvents\r\n        };\r\n        pos = this.clipPos( pos);\r\n        return p.markText(this, pos, pos, realOpts, 'bookmark');\r\n    },\r\n\r\n    findMarksAt: function (pos) {\r\n        pos = this.clipPos( pos);\r\n        let markers = [], spans = this.getLineHandle(pos.line).markedSpans;\r\n        if (spans)\r\n            for (let i = 0; i < spans.length; ++i) {\r\n                let span = spans[i];\r\n                if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))\r\n                    markers.push(span.marker.parent || span.marker);\r\n            }\r\n        return markers;\r\n    },\r\n\r\n    findMarks: function (from, to, filter) {\r\n        from = this.clipPos( from);\r\n        to = this.clipPos( to);\r\n        let found = [], lineNo = from.line;\r\n        this.iter(from.line, to.line + 1, line => {\r\n            let spans = line.markedSpans;\r\n            if (spans)\r\n                for (let i = 0; i < spans.length; i++) {\r\n                    let span = spans[i];\r\n                    if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker)))\r\n                        found.push(span.marker.parent || span.marker);\r\n                }\r\n            ++lineNo;\r\n        });\r\n        return found;\r\n    },\r\n\r\n    getAllMarks: function () {\r\n        let markers = [];\r\n        this.iter(line => {\r\n            let sps = line.markedSpans;\r\n            if (sps)\r\n                for (let i = 0; i < sps.length; ++i)\r\n                    if (sps[i].from != null)\r\n                        markers.push(sps[i].marker);\r\n        });\r\n        return markers;\r\n    },\r\n\r\n    posFromIndex: function (off) {\r\n        let ch, lineNo = this.first, sepSize = this.lineSeparator().length;\r\n        this.iter(line => {\r\n            let sz = line.text.length + sepSize;\r\n            if (sz > off) {\r\n                ch = off;\r\n                return true;\r\n            }\r\n            off -= sz;\r\n            ++lineNo;\r\n        });\r\n        return this.clipPos( new Position(lineNo, ch));\r\n    },\r\n\r\n    indexFromPos: function (coords) {\r\n        coords = this.clipPos( coords);\r\n        let index = coords.ch;\r\n        if (coords.line < this.first || coords.ch < 0)\r\n            return 0;\r\n        let sepSize = this.lineSeparator().length;\r\n        this.iter(this.first, coords.line, line => {\r\n            index += line.text.length + sepSize;\r\n        });\r\n        return index;\r\n    },\r\n    copy: function (copyHistory) {\r\n        let doc = new Document(this.getLines(this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);\r\n        doc.scrollTop = this.scrollTop;\r\n        doc.scrollLeft = this.scrollLeft;\r\n        doc.sel = this.sel;\r\n        doc.extend = false;\r\n        if (copyHistory) {\r\n            doc.history.undoDepth = this.history.undoDepth;\r\n            doc.setHistory(this.getHistory());\r\n        }\r\n        return doc;\r\n    },\r\n\r\n    linkedDoc: function (options) {\r\n        if (!options)\r\n            options = {};\r\n        let from = this.first, to = this.first + this.size;\r\n        if (options.from != null && options.from > from)\r\n            from = options.from;\r\n        if (options.to != null && options.to < to)\r\n            to = options.to;\r\n        let copy = new Document(this.getLines(from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\r\n        if (options.sharedHist)\r\n            copy.history = this.history;\r\n        (this.linked || (this.linked = [])).push({\r\n            doc: copy,\r\n            sharedHist: options.sharedHist\r\n        });\r\n        copy.linked = [{\r\n                doc: this,\r\n                isParent: true,\r\n                sharedHist: options.sharedHist\r\n            }];\r\n        line_widget.copySharedMarkers(copy, line_widget.findSharedMarkers(this));\r\n        return copy;\r\n    },\r\n\r\n    unlinkDoc: function (other) {\r\n        //if (other instanceof CodeMirror) // modified by lwf\r\n        if (other.doc)\r\n            other = other.doc;\r\n        if (this.linked)\r\n            for (let i = 0; i < this.linked.length; ++i) {\r\n                let link = this.linked[i];\r\n                if (link.doc != other)\r\n                    continue;\r\n                this.linked.splice(i, 1);\r\n                other.unlinkDoc(this);\r\n                line_widget.detachSharedMarkers(line_widget.findSharedMarkers(this));\r\n                break;\r\n            }\r\n        if (other.history == this.history) {\r\n            let splitIds = [other.id];\r\n            document_data.linkedDocs(other, doc => splitIds.push(doc.id), true);\r\n            other.history = new m_history.History(null);\r\n            other.history.done = m_history.copyHistoryArray(this.history.done, splitIds);\r\n            other.history.undone = m_history.copyHistoryArray(this.history.undone, splitIds);\r\n        }\r\n    },\r\n\r\n    iterLinkedDocs: function (f) {\r\n        document_data.linkedDocs(this, f);\r\n    },\r\n\r\n    getMode: function () {\r\n        return this.mode;\r\n    },\r\n\r\n    getEditor: function () {\r\n        return this.cm;\r\n    },\r\n\r\n    splitLines: function (str) {\r\n        if (this.lineSep)\r\n            return str.split(this.lineSep);\r\n        return feature_detection.splitLinesAuto(str);\r\n    },\r\n\r\n    lineSeparator: function () {\r\n        return this.lineSep || '\\n';\r\n    },\r\n\r\n    setDirection: function (dir) {\r\n        //operations.docMethodOp\r\n        if (dir != 'rtl')\r\n            dir = 'ltr';\r\n        if (dir == this.direction)\r\n            return;\r\n        this.direction = dir;\r\n        this.iter(line => line.order = null);\r\n        ///if (this.cm)\r\n        ///    document_data.directionChanged(this.cm);\r\n        this.emit(\"directionChanged\");\r\n    }\r\n  });\r\n    \r\n  // Public alias.\r\n  Document.prototype.eachLine = Document.prototype.iter;\r\n\r\n  return plain.Document = Document;\r\n});\r\n\ndefine('skylark-texts-plain/main',[\r\n\t\"./plain\",\r\n\t\"./position\",\r\n\t\"./range\",\r\n\t\"./selection\",\r\n\t\"./line\",\r\n\t\"./leaf_chunk\",\r\n\t\"./branch_chunk\",\r\n\t\"./document\"\r\n],function(plain){\r\n\treturn plain;\r\n});\ndefine('skylark-texts-plain', ['skylark-texts-plain/main'], function (main) { return main; });\n\n"]}