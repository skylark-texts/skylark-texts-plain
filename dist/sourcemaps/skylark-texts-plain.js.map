{"version":3,"sources":["skylark-texts-plain.js"],"names":["define","skylark","skyalark","attach","klass","objects","plain","Position","_construct","line","ch","sticky","this","compareTo","other","clone","thie","equals","clipToLen","linelen","compare","a","b","Postion","copy","x","max","cmp","min","equal","Range","klassName","anchor","head","from","Positon","to","empty","extend","posBefore","Selection","ranges","primIndex","primary","length","i","here","there","deepCopy","out","copyPos","somethingSelected","contains","pos","end","range","normalize","mayTouch","prim","sort","arrays","indexOf","cur","prev","diff","inv","splice","simple","Evented","Line","inherit","text","markedSpans","estimateHeight","attachMarkedSpans","updateLineHeight","height","lineNo","parent","no","lines","chunk","children","chunkSize","first","updateLine","stateAfter","styles","order","detachMarkedSpans","estHeight","cleanUpLine","countColumn","string","tabSize","startIndex","startValue","search","n","nextTab","findColumn","goal","col","skipped","Math","LeafChunk","removeInner","at","e","emit","collapse","push","apply","insertInner","slice","concat","iterN","op","BranchChunk","size","child","sz","rm","oldHeight","remaining","leaf","maybeSpill","me","spilled","sibling","myIndex","used","History","startGen","done","undone","undoDepth","Infinity","lastModTime","lastSelTime","lastOp","lastSelOp","lastOrigin","lastSelOrigin","generation","maxGeneration","historyChangeFromChange","doc","change","histChange","change_measurement","changeEnd","getBetween","attachLocalSpans","document_data","linkedDocs","clearSelectionEvents","array","last","pop","pushSelectionToHistory","sel","dest","top","existing","id","iter","removeClearedSpans","spans","marker","explicitlyCleared","addChangeToHistory","selAfter","opId","hist","history","time","Date","origin","charAt","cm","options","historyEventDelay","force","lastChangeEvent","changes","before","shift","addSelectionToHistory","selectionEventCanBeMerged","clearRedo","mergeOldSpans","old","found","nw","getOldSpans","stretched","stretchSpansOverChange","oldCur","stretchCur","j","span","k","copyHistoryArray","events","newGroup","instantiateSel","event","prototype","call","newChanges","m","prop","match","Number","nextDocId","Document","mode","firstLine","lineSep","direction","overrited","scrollTop","scrollLeft","cantEdit","cleanGeneration","modeFrontier","highlightFrontier","start","m_history","modeOption","splitLines","updateDoc","selection_updates","setSelection","misc","sel_dontScroll","insert","remove","getValue","getLines","join","lineSeparator","setValue","code","makeChange","getLineHandle","full","scrolling","scrollToCoords","replaceRange","clipPos","getRange","getLine","l","Error","getLineNumber","getLineHandleVisualStart","visualLine","isLine","lineCount","lastLine","getCursor","listSelections","setCursor","setSimpleSelection","extendSelection","extendSelections","heads","m_pos","clipPosArray","extendSelectionsBy","f","map","setSelections","m_selection","addSelection","normalizeSelection","getSelection","getSelections","parts","replaceSelection","dup","replaceSelections","newSel","computeReplacedSel","setSelectionReplaceHistory","ensureCursorVisible","undo","makeChangeFromHistory","redo","undoSelection","redoSelection","setExtending","val","getExtending","historySize","clearHistory","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","setGutterMarker","gutterID","value","changeLine","markers","gutterMarkers","isEmpty","clearGutter","lineInfo","handle","textClass","bgClass","wrapClass","widgets","addLineClass","where","cls","dom","classTest","test","removeLineClass","index","addLineWidget","node","line_widget","removeLineWidget","widget","clear","markText","mark_text","type","setBookmark","realOpts","replacedWith","nodeType","insertLeft","clearWhenEmpty","shared","handleMouseEvents","p","findMarksAt","findMarks","filter","getAllMarks","sps","posFromIndex","off","sepSize","indexFromPos","coords","copyHistory","linkedDoc","sharedHist","linked","isParent","copySharedMarkers","findSharedMarkers","unlinkDoc","link","detachSharedMarkers","splitIds","iterLinkedDocs","getMode","getEditor","str","split","feature_detection","splitLinesAuto","setDirection","dir","eachLine","main"],"mappings":"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","file":"../skylark-texts-plain.js","sourcesContent":["define('skylark-texts-plain/plain',[\r\n\t\"skylark-langx/skylark\"\r\n],function(skylark){\r\n\treturn skyalark.attach(\"plain.plain\")\r\n});\ndefine('skylark-texts-plain/position',[\r\n  \"skylark-langx/klass\",\r\n  \"skylark-langx/objects\",\r\n  \"./plain\"\r\n],function(klass,objects,plain) {\r\n  // POSITION OBJECT (original : line/pos.js)\r\n\r\n  // A Position instance represents a position within the text.\r\n  var Position = klass({\r\n    _construct : function(line,ch,sticky = null) {\r\n      this.line = line; \r\n      this.ch = ch;\r\n      this.sticky = sticky;\r\n    },\r\n    compareTo : function(other) {\r\n      return other && (this.line - other.line || this.ch - other.ch); \r\n    },\r\n\r\n    clone : function() {\r\n      return new Position(this.line,thie.ch);\r\n    },\r\n\r\n    equals : function(other) {\r\n        return other && (this.sticky == other.sticky && this.compareTo(other) == 0);    \r\n    },\r\n\r\n    clipToLen : function(linelen) {\r\n        let ch = this.ch;\r\n        if (ch == null || ch > linelen) {\r\n            return new Position(this.line, linelen);          \r\n        } else if (ch < 0) {\r\n            return new Position(this.line, 0);\r\n        } else {\r\n            return this;\r\n        }\r\n    }\r\n  });\r\n\r\n  // Compare two positions, return 0 if they are the same, a negative\r\n  // number when a is less, and a positive number otherwise.\r\n  Position.compare = function cmp(a, b) { \r\n    return a.compareTo(b);\r\n  };\r\n\r\n  Postion.copy = function copyPos(x) {\r\n    return x.clone();\r\n  }\r\n\r\n  Position.max = function maxPos(a, b) { \r\n    return cmp(a, b) < 0 ? b : a; \r\n  };\r\n\r\n  Position.min = function minPos(a, b) { \r\n    return cmp(a, b) < 0 ? a : b; \r\n  };\r\n\r\n  Position.equal = function equalCursorPos(a,b) {\r\n    return a && a.equals(b);\r\n  };\r\n\r\n  return plain.Position = Position;\r\n\r\n});\r\n\ndefine('skylark-texts-plain/range',[\r\n  \"skylark-langx/klass\",\r\n  \"./plain\",\r\n  \"./position\"\r\n],function(klass,plain,Postion) {\r\n  // Original: model/selection.js\r\n  \r\n  var Range = klass({\r\n    klassName : \"Range\",\r\n\r\n    _construct : function(anchor, head) {\r\n      this.anchor = anchor; \r\n      this.head = head;\r\n    },\r\n\r\n    from: function() { \r\n      return Positon.min(this.anchor, this.head); \r\n    },\r\n    \r\n    to: function() { \r\n      return Position.max(this.anchor, this.head); \r\n    },\r\n    \r\n    empty: function() {\r\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\r\n    },\r\n\r\n    extend : function extendRange(head, other, extend) {\r\n      // moved from model/selection_updates.js\r\n        if (extend) {\r\n          let anchor = this.anchor;\r\n          if (other) {\r\n              let posBefore = Position.compare(head, anchor) < 0;\r\n              if (posBefore != Position.compare(other, anchor) < 0) {\r\n                  anchor = head;\r\n                  head = other;\r\n              } else if (posBefore != Position.compare(head, other) < 0) {\r\n                  head = other;\r\n              }\r\n          }\r\n          return new Range(anchor, head);\r\n        } else {\r\n          return new Range(other || head, head);\r\n        }\r\n    }\r\n  });\r\n\r\n  return plain.Range = Range;\r\n\r\n});\r\n\ndefine('skylark-texts-plain/selection',[\r\n  \"skylark-langx/klass\",\r\n  \"./plain\",\r\n  \"./position\",\r\n  \"./range\"\r\n],function(klass,plain, Position, Range) {\r\n\r\n  // Original: model/selection.js\r\n\r\n  var Selection = klass({\r\n    klassName : \"Selection\",\r\n\r\n    _construct : function (ranges, primIndex) {\r\n      this.ranges = ranges;\r\n      this.primIndex = primIndex;\r\n    },\r\n    \r\n    primary: function() { \r\n      return this.ranges[this.primIndex]; \r\n    },\r\n    \r\n    equals: function(other) {\r\n      if (other == this) return true;\r\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\r\n      for (var i = 0; i < this.ranges.length; i++) {\r\n        var here = this.ranges[i], there = other.ranges[i];\r\n        if (Position.compare(here.anchor, there.anchor) != 0 || Position.compare(here.head, there.head) != 0) return false;\r\n      }\r\n      return true;\r\n    },\r\n    \r\n    deepCopy: function() {\r\n      for (var out = [], i = 0; i < this.ranges.length; i++)\r\n        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\r\n      return new Selection(out, this.primIndex);\r\n    },\r\n    \r\n    somethingSelected: function() {\r\n      for (var i = 0; i < this.ranges.length; i++)\r\n        if (!this.ranges[i].empty()) return true;\r\n      return false;\r\n    },\r\n    \r\n    contains: function(pos, end) {\r\n      if (!end) end = pos;\r\n      for (var i = 0; i < this.ranges.length; i++) {\r\n        var range = this.ranges[i];\r\n        if (Position.compare(end, range.from()) >= 0 && Position.compare(pos, range.to()) <= 0)\r\n          return i;\r\n      }\r\n      return -1;\r\n    }\r\n\r\n  });\r\n\r\n  // Take an unsorted, potentially overlapping set of ranges, and\r\n  // build a selection out of it. 'Consumes' ranges array (modifying\r\n  // it).\r\n\r\n  Selection.normalize =  function normalizeSelection(mayTouch, ranges, primIndex) {\r\n      //let mayTouch = cm && cm.options.selectionsMayTouch;\r\n      let prim = ranges[primIndex];\r\n      ranges.sort((a, b) => Position.compare(a.from(), b.from()));\r\n      primIndex = arrays.indexOf(ranges, prim);\r\n      for (let i = 1; i < ranges.length; i++) {\r\n          let cur = ranges[i], prev = ranges[i - 1];\r\n          let diff = Position.compare(prev.to(), cur.from());\r\n          if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\r\n              let from = Position.min(prev.from(), cur.from()), to = Position.max(prev.to(), cur.to());\r\n              let inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\r\n              if (i <= primIndex)\r\n                  --primIndex;\r\n              ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\r\n          }\r\n      }\r\n      return new Selection(ranges, primIndex);\r\n  };\r\n\r\n  Selection.simple =  function simpleSelection(anchor, head) {\r\n    return new Selection([new Range(anchor, head || anchor)], 0);\r\n  };\r\n\r\n  return plain.Selection = Selection;\r\n});\n define('skylark-texts-plain/line',[\r\n  \"skylark-langx/Evented\",\r\n  \"./plain\"\r\n],function(Evented,plain){\r\n\r\n  // LINE DATA STRUCTURE\r\n\r\n  // Line objects. These hold state related to a line, including\r\n  // highlighting info (the styles array).\r\n  var Line = Evented.inherit({\r\n    _construct : function(text, markedSpans, estimateHeight) {\r\n      this.text = text;\r\n      //TODO : The following logic will been changing\r\n      if (this.attachMarkedSpans) {\r\n        this.attachMarkedSpans(markedSpans);      \r\n      }\r\n      if (this.updateLineHeight) {\r\n        this.height = estimateHeight ? estimateHeight(this) : 1;\r\n      }\r\n    },\r\n\r\n    lineNo : function() { \r\n      //return lineNo(this); \r\n      var line = this;\r\n      if (line.parent == null) {\r\n        return null;\r\n      }\r\n      var cur = line.parent, no = indexOf(cur.lines, line);\r\n      for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\r\n        for (var i = 0;; ++i) {\r\n          if (chunk.children[i] == cur) break;\r\n          no += chunk.children[i].chunkSize();\r\n        }\r\n      }\r\n      return no + cur.first;\r\n    },\r\n\r\n    // Change the content (text, markers) of a line. Automatically\r\n    // invalidates cached information and tries to re-estimate the\r\n    // line's height.\r\n    updateLine : function (text, markedSpans, estimateHeight) {\r\n      var line = this;\r\n\r\n      line.text = text;\r\n      if (line.stateAfter) line.stateAfter = null;\r\n      if (line.styles) line.styles = null;\r\n      if (line.order != null) line.order = null;\r\n\r\n\r\n      //TODO : The following logic will been changing\r\n\r\n      if (this.detachMarkedSpans) {\r\n        line.detachMarkedSpans();\r\n      }\r\n      if (this.attachMarkedSpans) {\r\n        line.attachMarkedSpans( markedSpans);\r\n      }\r\n      if (this.updateLineHeight) {\r\n        var estHeight = estimateHeight ? estimateHeight(line) : 1;\r\n        if (estHeight != line.height) line.updateLineHeight(estHeight);\r\n      }\r\n    },\r\n\r\n    // Detach a line from the document tree and its markers.\r\n    cleanUpLine : function () {\r\n      var line = this;\r\n      line.parent = null;\r\n\r\n      //TODO : The following logic will been changing\r\n      if (this.detachMarkedSpans) {\r\n        line.detachMarkedSpans();\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n\r\n  function extractLineClasses(type, output) {\r\n    if (type) for (;;) {\r\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\r\n      if (!lineClass) break;\r\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\r\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\r\n      if (output[prop] == null)\r\n        output[prop] = lineClass[2];\r\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\r\n        output[prop] += \" \" + lineClass[2];\r\n    }\r\n    return type;\r\n  }\r\n\r\n  function callBlankLine(mode, state) {\r\n    if (mode.blankLine) return mode.blankLine(state);\r\n    if (!mode.innerMode) return;\r\n    var inner = CodeMirror.innerMode(mode, state);\r\n    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\r\n  }\r\n\r\n  // Counts the column offset in a string, taking tabs into account.\r\n  // Used mostly to find indentation.\r\n  var countColumn = Line.countColumn = function(string, end, tabSize, startIndex, startValue) {\r\n    if (end == null) {\r\n      end = string.search(/[^\\s\\u00a0]/);\r\n      if (end == -1) end = string.length;\r\n    }\r\n    for (var i = startIndex || 0, n = startValue || 0;;) {\r\n      var nextTab = string.indexOf(\"\\t\", i);\r\n      if (nextTab < 0 || nextTab >= end)\r\n        return n + (end - i);\r\n      n += nextTab - i;\r\n      n += tabSize - (n % tabSize);\r\n      i = nextTab + 1;\r\n    }\r\n  };\r\n\r\n  // The inverse of countColumn -- find the offset that corresponds to\r\n  // a particular column.\r\n  var findColumn = Line.findColumn = function(string, goal, tabSize) {\r\n    for (var pos = 0, col = 0;;) {\r\n      var nextTab = string.indexOf(\"\\t\", pos);\r\n      if (nextTab == -1) nextTab = string.length;\r\n      var skipped = nextTab - pos;\r\n      if (nextTab == string.length || col + skipped >= goal)\r\n        return pos + Math.min(skipped, goal - col);\r\n      col += nextTab - pos;\r\n      col += tabSize - (col % tabSize);\r\n      pos = nextTab + 1;\r\n      if (col >= goal) return pos;\r\n    }\r\n  }\r\n\r\n  return plain.Line = Line;\r\n\r\n});\r\n\r\n\ndefine('skylark-texts-plain/leaf_chunk',[\r\n  \"skylark-langx/Evented\",\r\n  \"./plain\"\r\n],function(Evented,plain){\r\n  // Original: model/chunk.js\r\n\r\n  var LeafChunk = Evented.inherit({\r\n    klassName : \"LeafChunk\",\r\n\r\n    _construct :  function(lines) {\r\n      this.lines = lines;\r\n      this.parent = null;\r\n      for (var i = 0, height = 0; i < lines.length; ++i) {\r\n        lines[i].parent = this;\r\n        height += lines[i].height;\r\n      }\r\n      this.height = height;\r\n    },\r\n\r\n    chunkSize: function() { \r\n      return this.lines.length; \r\n    },\r\n    \r\n    // Remove the n lines at offset 'at'.\r\n    removeInner: function(at, n) {\r\n      for (var i = at, e = at + n; i < e; ++i) {\r\n        var line = this.lines[i];\r\n        this.height -= line.height;\r\n        line.cleanUpLine();\r\n        //signalLater(line, \"delete\");\r\n        this.emit(\"delete\",line)\r\n      }\r\n      this.lines.splice(at, n);\r\n    },\r\n\r\n    // Helper used to collapse a small branch into a single leaf.\r\n    collapse: function(lines) {\r\n      lines.push.apply(lines, this.lines);\r\n    },\r\n\r\n    // Insert the given array of lines at offset 'at', count them as\r\n    // having the given height.\r\n    insertInner: function(at, lines, height) {\r\n      this.height += height;\r\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\r\n      for (var i = 0; i < lines.length; ++i) {\r\n        lines[i].parent = this;\r\n      }\r\n    },\r\n\r\n    // Used to iterate over a part of the tree.\r\n    iterN: function(at, n, op) {\r\n      for (var e = at + n; at < e; ++at)\r\n        if (op(this.lines[at])) {\r\n          return true;\r\n        }\r\n    }\r\n  });\r\n\r\n  return  plain.LeafChunk = LeafChunk;\r\n\r\n});\ndefine('skylark-texts-plain/branch_chunk',[\r\n  \"skylark-langx/Evented\",\r\n  \"./plain\",\r\n  \"./leaf_chunk\"\r\n],function(Evented,plain,LeafChunk){\r\n  // Original: model/chunk.js\r\n\r\n  var BranchChunk = Evented.inherit({\r\n    klassName : \"BranchChunk\",\r\n\r\n    _construct : function (children) {\r\n      this.children = children;\r\n      var size = 0, height = 0;\r\n      for (var i = 0; i < children.length; ++i) {\r\n        var ch = children[i];\r\n        size += ch.chunkSize(); height += ch.height;\r\n        ch.parent = this;\r\n      }\r\n      this.size = size;\r\n      this.height = height;\r\n      this.parent = null;\r\n    },\r\n\r\n    chunkSize: function() { \r\n      return this.size; \r\n    },\r\n    \r\n    removeInner: function(at, n) {\r\n      this.size -= n;\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at < sz) {\r\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\r\n          child.removeInner(at, rm);\r\n          this.height -= oldHeight - child.height;\r\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\r\n          if ((n -= rm) == 0) break;\r\n          at = 0;\r\n        } else at -= sz;\r\n      }\r\n      // If the result is smaller than 25 lines, ensure that it is a\r\n      // single leaf node.\r\n      if (this.size - n < 25 &&\r\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\r\n        var lines = [];\r\n        this.collapse(lines);\r\n        this.children = [new LeafChunk(lines)];\r\n        this.children[0].parent = this;\r\n      }\r\n    },\r\n\r\n    collapse: function(lines) {\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        this.children[i].collapse(lines);\r\n      }\r\n    },\r\n\r\n    insertInner: function(at, lines, height) {\r\n      this.size += lines.length;\r\n      this.height += height;\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at <= sz) {\r\n          child.insertInner(at, lines, height);\r\n          if (child.lines && child.lines.length > 50) {\r\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\r\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\r\n            var remaining = child.lines.length % 25 + 25\r\n            for (var pos = remaining; pos < child.lines.length;) {\r\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\r\n              child.height -= leaf.height;\r\n              this.children.splice(++i, 0, leaf);\r\n              leaf.parent = this;\r\n            }\r\n            child.lines = child.lines.slice(0, remaining);\r\n            this.maybeSpill();\r\n          }\r\n          break;\r\n        }\r\n        at -= sz;\r\n      }\r\n    },\r\n    // When a node has grown, check whether it should be split.\r\n    maybeSpill: function() {\r\n      if (this.children.length <= 10) return;\r\n      var me = this;\r\n      do {\r\n        var spilled = me.children.splice(me.children.length - 5, 5);\r\n        var sibling = new BranchChunk(spilled);\r\n        if (!me.parent) { // Become the parent node\r\n          var copy = new BranchChunk(me.children);\r\n          copy.parent = me;\r\n          me.children = [copy, sibling];\r\n          me = copy;\r\n       } else {\r\n          me.size -= sibling.size;\r\n          me.height -= sibling.height;\r\n          var myIndex = indexOf(me.parent.children, me);\r\n          me.parent.children.splice(myIndex + 1, 0, sibling);\r\n        }\r\n        sibling.parent = me.parent;\r\n      } while (me.children.length > 10);\r\n      me.parent.maybeSpill();\r\n    },\r\n    \r\n    iterN: function(at, n, op) {\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at < sz) {\r\n          var used = Math.min(n, sz - at);\r\n          if (child.iterN(at, used, op)) return true;\r\n          if ((n -= used) == 0) break;\r\n          at = 0;\r\n        } else at -= sz;\r\n      }\r\n    }\r\n  });\r\n\r\n  return plain.BranchChunk = BranchChunk;\r\n});\r\n\ndefine('skylark-texts-plain/history',[\r\n    \"skylark-langx-arrays\",\r\n    './position',\r\n    './selection'\r\n], function (arrays,Position,  Selection) {\r\n    'use strict';\r\n\r\n    //TODO:spans/change_measurement/document_data\r\n\r\n    function History(startGen) {\r\n        this.done = [];\r\n        this.undone = [];\r\n        this.undoDepth = Infinity;\r\n        this.lastModTime = this.lastSelTime = 0;\r\n        this.lastOp = this.lastSelOp = null;\r\n        this.lastOrigin = this.lastSelOrigin = null;\r\n        this.generation = this.maxGeneration = startGen || 1;\r\n    }\r\n\r\n    function historyChangeFromChange(doc, change) {\r\n        let histChange = {\r\n            from: Position.copy(change.from),\r\n            to: change_measurement.changeEnd(change),\r\n            text: doc.getBetween(change.from, change.to)\r\n        };\r\n        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\r\n        document_data.linkedDocs(doc, doc => attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1), true);\r\n        return histChange;\r\n    }\r\n\r\n    function clearSelectionEvents(array) {\r\n        while (array.length) {\r\n            let last = arrays.last(array);\r\n            if (last.ranges)\r\n                array.pop();\r\n            else\r\n                break;\r\n        }\r\n    }\r\n\r\n    function lastChangeEvent(hist, force) {\r\n        if (force) {\r\n            clearSelectionEvents(hist.done);\r\n            return arrays.last(hist.done);\r\n        } else if (hist.done.length && !arrays.last(hist.done).ranges) {\r\n            return arrays.last(hist.done);\r\n        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\r\n            hist.done.pop();\r\n            return arrays.last(hist.done);\r\n        }\r\n    }\r\n    function addChangeToHistory(doc, change, selAfter, opId) {\r\n        let hist = doc.history;\r\n        hist.undone.length = 0;\r\n        let time = +new Date(), cur;\r\n        let last;\r\n        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == '*')) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\r\n            last = arrays.last(cur.changes);\r\n            if (Position.compare(change.from, change.to) == 0 && Position.compare(change.from, last.to) == 0) {\r\n                last.to = change_measurement.changeEnd(change);\r\n            } else {\r\n                cur.changes.push(historyChangeFromChange(doc, change));\r\n            }\r\n        } else {\r\n            let before = arrays.last(hist.done);\r\n            if (!before || !before.ranges)\r\n                pushSelectionToHistory(doc.sel, hist.done);\r\n            cur = {\r\n                changes: [historyChangeFromChange(doc, change)],\r\n                generation: hist.generation\r\n            };\r\n            hist.done.push(cur);\r\n            while (hist.done.length > hist.undoDepth) {\r\n                hist.done.shift();\r\n                if (!hist.done[0].ranges)\r\n                    hist.done.shift();\r\n            }\r\n        }\r\n        hist.done.push(selAfter);\r\n        hist.generation = ++hist.maxGeneration;\r\n        hist.lastModTime = hist.lastSelTime = time;\r\n        hist.lastOp = hist.lastSelOp = opId;\r\n        hist.lastOrigin = hist.lastSelOrigin = change.origin;\r\n        if (!last)\r\n            doc.emit('historyAdded');\r\n    }\r\n\r\n    function selectionEventCanBeMerged(doc, origin, prev, sel) {\r\n        let ch = origin.charAt(0);\r\n        return ch == '*' || ch == '+' && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\r\n    }\r\n\r\n    function addSelectionToHistory(doc, sel, opId, options) {\r\n        let hist = doc.history, origin = options && options.origin;\r\n        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, arrays.last(hist.done), sel)))\r\n            hist.done[hist.done.length - 1] = sel;\r\n        else\r\n            pushSelectionToHistory(sel, hist.done);\r\n        hist.lastSelTime = +new Date();\r\n        hist.lastSelOrigin = origin;\r\n        hist.lastSelOp = opId;\r\n        if (options && options.clearRedo !== false)\r\n            clearSelectionEvents(hist.undone);\r\n    }\r\n\r\n    function pushSelectionToHistory(sel, dest) {\r\n        let top = arrays.last(dest);\r\n        if (!(top && top.ranges && top.equals(sel)))\r\n            dest.push(sel);\r\n    }\r\n\r\n    function attachLocalSpans(doc, change, from, to) {\r\n        let existing = change['spans_' + doc.id], n = 0;\r\n        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), line => {\r\n            if (line.markedSpans)\r\n                (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;\r\n            ++n;\r\n        });\r\n    }\r\n\r\n    function removeClearedSpans(spans) {\r\n        if (!spans)\r\n            return null;\r\n        let out;\r\n        for (let i = 0; i < spans.length; ++i) {\r\n            if (spans[i].marker.explicitlyCleared) {\r\n                if (!out)\r\n                    out = spans.slice(0, i);\r\n            } else if (out)\r\n                out.push(spans[i]);\r\n        }\r\n        return !out ? spans : out.length ? out : null;\r\n    }\r\n\r\n    function getOldSpans(doc, change) {\r\n        let found = change['spans_' + doc.id];\r\n        if (!found)\r\n            return null;\r\n        let nw = [];\r\n        for (let i = 0; i < change.text.length; ++i)\r\n            nw.push(removeClearedSpans(found[i]));\r\n        return nw;\r\n    }\r\n\r\n    function mergeOldSpans(doc, change) {\r\n        let old = getOldSpans(doc, change);\r\n        let stretched = spans.stretchSpansOverChange(doc, change);\r\n        if (!old)\r\n            return stretched;\r\n        if (!stretched)\r\n            return old;\r\n        for (let i = 0; i < old.length; ++i) {\r\n            let oldCur = old[i], stretchCur = stretched[i];\r\n            if (oldCur && stretchCur) {\r\n                spans:\r\n                    for (let j = 0; j < stretchCur.length; ++j) {\r\n                        let span = stretchCur[j];\r\n                        for (let k = 0; k < oldCur.length; ++k)\r\n                            if (oldCur[k].marker == span.marker)\r\n                                continue spans;\r\n                        oldCur.push(span);\r\n                    }\r\n            } else if (stretchCur) {\r\n                old[i] = stretchCur;\r\n            }\r\n        }\r\n        return old;\r\n    }\r\n\r\n    function copyHistoryArray(events, newGroup, instantiateSel) {\r\n        let copy = [];\r\n        for (let i = 0; i < events.length; ++i) {\r\n            let event = events[i];\r\n            if (event.ranges) {\r\n                copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\r\n                continue;\r\n            }\r\n            let changes = event.changes, newChanges = [];\r\n            copy.push({ changes: newChanges });\r\n            for (let j = 0; j < changes.length; ++j) {\r\n                let change = changes[j], m;\r\n                newChanges.push({\r\n                    from: change.from,\r\n                    to: change.to,\r\n                    text: change.text\r\n                });\r\n                if (newGroup)\r\n                    for (var prop in change)\r\n                        if (m = prop.match(/^spans_(\\d+)$/)) {\r\n                            if (arrays.indexOf(newGroup, Number(m[1])) > -1) {\r\n                                arrays.last(newChanges)[prop] = change[prop];\r\n                                delete change[prop];\r\n                            }\r\n                        }\r\n            }\r\n        }\r\n        return copy;\r\n    }\r\n\r\n    History.historyChangeFromChange = historyChangeFromChange;\r\n    History.addChangeToHistory = addChangeToHistory;\r\n    History.addSelectionToHistory = addSelectionToHistory;\r\n    History.pushSelectionToHistory = pushSelectionToHistory;\r\n    History.mergeOldSpans = mergeOldSpans;\r\n    History.copyHistoryArray = copyHistoryArray;\r\n\r\n    return History;\r\n});\ndefine('skylark-texts-plain/document',[\r\n  \"skylark-langx/arrays\",\r\n  \"skylark-langx/Evented\",\r\n  \"./plain\",\r\n  \"./branch_chunk\",\r\n  \"./leaf_chunk\",\r\n  \"./position\",\r\n  \"./selection\",\r\n  \"./history\"\r\n],function(arrays, Evented,plain,BranchChunk,LeafChunk,Position,Selection, History){\r\n    // Original : model/doc.js \r\n    //TODO : selection_updates/history/marker\r\n    'use strict';\r\n    let nextDocId = 0;\r\n\r\n  // The document is represented as a BTree consisting of leaves, with\r\n  // chunk of lines in them, and branches, with up to ten leaves or\r\n  // other branch nodes below them. The top node is always a branch\r\n  // node, and is the document object itself (meaning it has\r\n  // additional methods and properties).\r\n  //\r\n  // All nodes have parent links. The tree is used both to go from\r\n  // line numbers to line objects, and to go from objects to numbers.\r\n  // It also indexes by height, and is used to convert between height\r\n  // and line object, and to find the total height of the document.\r\n  //\r\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\r\n  \r\n  var Document = BranchChunk.inherit({\r\n\r\n    _construct : function(text, mode, firstLine, lineSep,direction) {\r\n      if (firstLine == null) firstLine = 0;\r\n\r\n      thie.overrited(new LeafChunk([new Line(\"\", null)]));\r\n\r\n      this.first = firstLine;\r\n      this.scrollTop = this.scrollLeft = 0;\r\n      this.cantEdit = false;\r\n      this.cleanGeneration = 1;\r\n      this.modeFrontier = this.highlightFrontier = firstLine;\r\n      let start = new Position(firstLine, 0);\r\n      this.sel = Selection.simple(start);\r\n      this.history = new m_history.History(null);\r\n      this.id = ++nextDocId;\r\n      this.modeOption = mode;\r\n      this.lineSep = lineSep;\r\n      this.direction = direction == 'rtl' ? 'rtl' : 'ltr';\r\n      this.extend = false;\r\n      if (typeof text == 'string') {\r\n          text = this.splitLines(text);\r\n      }\r\n      document_data.updateDoc(this, {\r\n          from: start,\r\n          to: start,\r\n          text: text\r\n      });\r\n      selection_updates.setSelection(this, Selection.simple(start), misc.sel_dontScroll);\r\n    },\r\n\r\n    iter: function (from, to, op) {\r\n        if (op) {\r\n          this.iterN(from - this.first, to - from, op);\r\n        } else {\r\n          this.iterN(this.first, this.first + this.size, from);\r\n        }\r\n    },\r\n\r\n    insert: function (at, lines) {\r\n        let height = 0;\r\n        for (let i = 0; i < lines.length; ++i) {\r\n            height += lines[i].height;\r\n        }\r\n        this.insertInner(at - this.first, lines, height);\r\n    },\r\n\r\n    remove: function (at, n) {\r\n        this.removeInner(at - this.first, n);\r\n    },\r\n\r\n    getValue: function (lineSep) {\r\n        let lines = this.getLines(this.first, this.first + this.size);\r\n        if (lineSep === false)\r\n            return lines;\r\n        return lines.join(lineSep || this.lineSeparator());\r\n    },\r\n\r\n    setValue: function (code) {\r\n        //operations.docMethodOp\r\n        let top = new Position(this.first, 0), last = this.first + this.size - 1;\r\n        changes.makeChange(this, {\r\n            from: top,\r\n            to: new Position(last, this.getLineHandle(last).text.length),\r\n            text: this.splitLines(code),\r\n            origin: 'setValue',\r\n            full: true\r\n        }, true);\r\n        if (this.cm)\r\n            scrolling.scrollToCoords(this.cm, 0, 0);\r\n        selection_updates.setSelection(this, Selection.simple(top), misc.sel_dontScroll);\r\n    },\r\n\r\n    replaceRange: function (code, from, to, origin) {\r\n        from = this.clipPos( from);\r\n        to = to ? this.clipPos( to) : from;\r\n        changes.replaceRange(this, code, from, to, origin);\r\n    },\r\n\r\n    getRange: function (from, to, lineSep) {\r\n        let lines = this.getBetween(this.clipPos( from), this.clipPos( to));\r\n        if (lineSep === false)\r\n            return lines;\r\n        return lines.join(lineSep || this.lineSeparator());\r\n    },\r\n\r\n    getBetween : function (start, end) {\r\n        // moved from line/utils_line.js\r\n        let doc = this,\r\n            out = [], n = start.line;\r\n        doc.iter(start.line, end.line + 1, line => {\r\n            let text = line.text;\r\n            if (n == end.line)\r\n                text = text.slice(0, end.ch);\r\n            if (n == start.line)\r\n                text = text.slice(start.ch);\r\n            out.push(text);\r\n            ++n;\r\n        });\r\n        return out;\r\n    },\r\n\r\n    getLine: function (line) {\r\n        let l = this.getLineHandle(line);\r\n        return l && l.text;\r\n    },\r\n\r\n    getLines : function (from, to) {\r\n        // moved from line/utils_line.js\r\n        let doc = this,\r\n            out = [];\r\n        doc.iter(from, to, line => {\r\n            out.push(line.text);\r\n        });\r\n        return out;\r\n    },\r\n\r\n    getLineHandle: function (n) {\r\n        ///return utils_line.getLine(this, n);\r\n\r\n        // moved from line/utils_line.js\r\n        n -= this.first;\r\n        if (n < 0 || n >= this.size)\r\n            throw new Error('There is no line ' + (n + this.first) + ' in the document.');\r\n        let chunk = this;\r\n        while (!chunk.lines) {\r\n            for (let i = 0;; ++i) {\r\n                let child = chunk.children[i], sz = child.chunkSize();\r\n                if (n < sz) {\r\n                    chunk = child;\r\n                    break;\r\n                }\r\n                n -= sz;\r\n            }\r\n        }\r\n        return chunk.lines[n];\r\n    },\r\n\r\n    getLineNumber: function (line) {\r\n        ///return utils_line.lineNo(line);\r\n        // moved from line/utils_line.js\r\n        if (line.parent == null)\r\n            return null;\r\n        let cur = line.parent, no = arrays.indexOf(cur.lines, line);\r\n        for (let chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\r\n            for (let i = 0;; ++i) {\r\n                if (chunk.children[i] == cur)\r\n                    break;\r\n                no += chunk.children[i].chunkSize();\r\n            }\r\n        }\r\n        return no + cur.first;\r\n    },\r\n\r\n    getLineHandleVisualStart: function (line) {\r\n        if (typeof line == 'number')\r\n            line = this.getLineHandle(line);\r\n        return spans.visualLine(line);\r\n    },\r\n\r\n    isLine : function(l) {\r\n        // moved from line/utils_line.js\r\n        return l >= this.first && l < this.first + this.size;        \r\n    },\r\n\r\n    lineCount: function () {\r\n        return this.size;\r\n    },\r\n\r\n    firstLine: function () {\r\n        return this.first;\r\n    },\r\n\r\n    lastLine: function () {\r\n        return this.first + this.size - 1;\r\n    },\r\n\r\n    clipPos: function (pos) {\r\n        ///return m_pos.clipPos(this, pos);\r\n        //moved from line/pos.js\r\n        if (pos.line < this.first)\r\n            return  new Position(this.first, 0);\r\n        let last = this.first + this.size - 1;\r\n        if (pos.line > last)\r\n            return Position(last, this.getLineHandle(last).text.length);\r\n        return pos.clipToLen(this.getLineHandle(pos.line).text.length);\r\n    },\r\n\r\n    getCursor: function (start) {\r\n        let range = this.sel.primary(), pos;\r\n        if (start == null || start == 'head')\r\n            pos = range.head;\r\n        else if (start == 'anchor')\r\n            pos = range.anchor;\r\n        else if (start == 'end' || start == 'to' || start === false)\r\n            pos = range.to();\r\n        else\r\n            pos = range.from();\r\n        return pos;\r\n    },\r\n\r\n    listSelections: function () {\r\n        return this.sel.ranges;\r\n    },\r\n\r\n    somethingSelected: function () {\r\n        return this.sel.somethingSelected();\r\n    },\r\n\r\n\r\n    setCursor: function (line, ch, options) {\r\n        //operations.docMethodOp\r\n        selection_updates.setSimpleSelection(this, this.clipPos( typeof line == 'number' ? new Position(line, ch || 0) : line), null, options);\r\n    },\r\n\r\n    setSelection: function (anchor, head, options) {\r\n        //operations.docMethodOp\r\n        selection_updates.setSimpleSelection(this, this.clipPos( anchor), this.clipPos( head || anchor), options);\r\n    },\r\n\r\n    extendSelection: function (head, other, options) {\r\n        //operations.docMethodOp\r\n        selection_updates.extendSelection(this, this.clipPos( head), other && this.clipPos( other), options);\r\n    },\r\n\r\n    extendSelections: function (heads, options) {\r\n        //operations.docMethodOp\r\n        selection_updates.extendSelections(this, m_pos.clipPosArray(this, heads), options);\r\n    },\r\n\r\n    extendSelectionsBy: function (f, options) {\r\n        //operations.docMethodOp\r\n        let heads = misc.map(this.sel.ranges, f);\r\n        selection_updates.extendSelections(this, m_pos.clipPosArray(this, heads), options);\r\n    },\r\n\r\n    setSelections: function (ranges, primary, options) {\r\n        //operations.docMethodOp\r\n        if (!ranges.length)\r\n            return;\r\n        let out = [];\r\n        for (let i = 0; i < ranges.length; i++)\r\n            out[i] = new m_selection.Range(this.clipPos( ranges[i].anchor), this.clipPos( ranges[i].head));\r\n        if (primary == null)\r\n            primary = Math.min(ranges.length - 1, this.sel.primIndex);\r\n        selection_updates.setSelection(this, Selection.normalize(this.cm, out, primary), options);\r\n    },\r\n\r\n    addSelection: function (anchor, head, options) {\r\n        //operations.docMethodOp\r\n        let ranges = this.sel.ranges.slice(0);\r\n        ranges.push(new m_selection.Range(this.clipPos( anchor), this.clipPos( head || anchor)));\r\n        selection_updates.setSelection(this, m_selection.normalizeSelection(this.cm, ranges, ranges.length - 1), options);\r\n    },\r\n\r\n    getSelection: function (lineSep) {\r\n        let ranges = this.sel.ranges, lines;\r\n        for (let i = 0; i < ranges.length; i++) {\r\n            let sel = this.getBetween(ranges[i].from(), ranges[i].to());\r\n            lines = lines ? lines.concat(sel) : sel;\r\n        }\r\n        if (lineSep === false)\r\n            return lines;\r\n        else\r\n            return lines.join(lineSep || this.lineSeparator());\r\n    },\r\n    getSelections: function (lineSep) {\r\n        let parts = [], ranges = this.sel.ranges;\r\n        for (let i = 0; i < ranges.length; i++) {\r\n            let sel = this.getBetween(ranges[i].from(), ranges[i].to());\r\n            if (lineSep !== false)\r\n                sel = sel.join(lineSep || this.lineSeparator());\r\n            parts[i] = sel;\r\n        }\r\n        return parts;\r\n    },\r\n    replaceSelection: function (code, collapse, origin) {\r\n        let dup = [];\r\n        for (let i = 0; i < this.sel.ranges.length; i++)\r\n            dup[i] = code;\r\n        this.replaceSelections(dup, collapse, origin || '+input');\r\n    },\r\n\r\n    replaceSelections: function (code, collapse, origin) {\r\n        //operations.docMethodOp\r\n        let changes = [], sel = this.sel;\r\n        for (let i = 0; i < sel.ranges.length; i++) {\r\n            let range = sel.ranges[i];\r\n            changes[i] = {\r\n                from: range.from(),\r\n                to: range.to(),\r\n                text: this.splitLines(code[i]),\r\n                origin: origin\r\n            };\r\n        }\r\n        let newSel = collapse && collapse != 'end' && change_measurement.computeReplacedSel(this, changes, collapse);\r\n        for (let i = changes.length - 1; i >= 0; i--)\r\n            changes.makeChange(this, changes[i]);\r\n        if (newSel)\r\n            selection_updates.setSelectionReplaceHistory(this, newSel);\r\n        else if (this.cm)\r\n            scrolling.ensureCursorVisible(this.cm);\r\n    },\r\n\r\n    undo: function () {\r\n        //operations.docMethodOp\r\n        changes.makeChangeFromHistory(this, 'undo');\r\n    },\r\n\r\n    redo: function () {\r\n        //operations.docMethodOp\r\n        changes.makeChangeFromHistory(this, 'redo');\r\n    },\r\n\r\n    undoSelection: function () {\r\n        //operations.docMethodOp\r\n        changes.makeChangeFromHistory(this, 'undo', true);\r\n    },\r\n\r\n    redoSelection: function () {\r\n        //operations.docMethodOp\r\n        changes.makeChangeFromHistory(this, 'redo', true);\r\n    },\r\n\r\n    setExtending: function (val) {\r\n        this.extend = val;\r\n    },\r\n\r\n    getExtending: function () {\r\n        return this.extend;\r\n    },\r\n\r\n    historySize: function () {\r\n        let hist = this.history, done = 0, undone = 0;\r\n        for (let i = 0; i < hist.done.length; i++)\r\n            if (!hist.done[i].ranges)\r\n                ++done;\r\n        for (let i = 0; i < hist.undone.length; i++)\r\n            if (!hist.undone[i].ranges)\r\n                ++undone;\r\n        return {\r\n            undo: done,\r\n            redo: undone\r\n        };\r\n    },\r\n\r\n    clearHistory: function () {\r\n        this.history = new m_history.History(this.history.maxGeneration);\r\n    },\r\n\r\n    markClean: function () {\r\n        this.cleanGeneration = this.changeGeneration(true);\r\n    },\r\n\r\n    changeGeneration: function (forceSplit) {\r\n        if (forceSplit)\r\n            this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\r\n        return this.history.generation;\r\n    },\r\n\r\n    isClean: function (gen) {\r\n        return this.history.generation == (gen || this.cleanGeneration);\r\n    },\r\n\r\n    getHistory: function () {\r\n        return {\r\n            done: m_history.copyHistoryArray(this.history.done),\r\n            undone: m_history.copyHistoryArray(this.history.undone)\r\n        };\r\n    },\r\n\r\n    setHistory: function (histData) {\r\n        let hist = this.history = new m_history.History(this.history.maxGeneration);\r\n        hist.done = m_history.copyHistoryArray(histData.done.slice(0), null, true);\r\n        hist.undone = m_history.copyHistoryArray(histData.undone.slice(0), null, true);\r\n    },\r\n\r\n    setGutterMarker: function (line, gutterID, value) {\r\n        //operations.docMethodOp\r\n        return changes.changeLine(this, line, 'gutter', line => {\r\n            let markers = line.gutterMarkers || (line.gutterMarkers = {});\r\n            markers[gutterID] = value;\r\n            if (!value && misc.isEmpty(markers))\r\n                line.gutterMarkers = null;\r\n            return true;\r\n        });\r\n    },\r\n\r\n    clearGutter: function (gutterID) {\r\n        //operations.docMethodOp\r\n        this.iter(line => {\r\n            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\r\n                changes.changeLine(this, line, 'gutter', () => {\r\n                    line.gutterMarkers[gutterID] = null;\r\n                    if (misc.isEmpty(line.gutterMarkers))\r\n                        line.gutterMarkers = null;\r\n                    return true;\r\n                });\r\n            }\r\n        });\r\n    },\r\n\r\n    lineInfo: function (line) {\r\n        let n;\r\n        if (typeof line == 'number') {\r\n            if (!this.isLine(line))\r\n                return null;\r\n            n = line;\r\n            line = this.getLineHandle(line);\r\n            if (!line)\r\n                return null;\r\n        } else {\r\n            n = this.getLineNumber(line);\r\n            if (n == null)\r\n                return null;\r\n        }\r\n        return {\r\n            line: n,\r\n            handle: line,\r\n            text: line.text,\r\n            gutterMarkers: line.gutterMarkers,\r\n            textClass: line.textClass,\r\n            bgClass: line.bgClass,\r\n            wrapClass: line.wrapClass,\r\n            widgets: line.widgets\r\n        };\r\n    },\r\n\r\n    addLineClass: function (handle, where, cls) {\r\n        //operations.docMethodOp\r\n        return changes.changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', line => {\r\n            let prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';\r\n            if (!line[prop])\r\n                line[prop] = cls;\r\n            else if (dom.classTest(cls).test(line[prop]))\r\n                return false;\r\n            else\r\n                line[prop] += ' ' + cls;\r\n            return true;\r\n        });\r\n    },\r\n\r\n    removeLineClass: function (handle, where, cls) {\r\n        //operations.docMethodOp\r\n        return changes.changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', line => {\r\n            let prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';\r\n            let cur = line[prop];\r\n            if (!cur)\r\n                return false;\r\n            else if (cls == null)\r\n                line[prop] = null;\r\n            else {\r\n                let found = cur.match(dom.classTest(cls));\r\n                if (!found)\r\n                    return false;\r\n                let end = found.index + found[0].length;\r\n                line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? '' : ' ') + cur.slice(end) || null;\r\n            }\r\n            return true;\r\n        });\r\n    },\r\n\r\n    addLineWidget: function (handle, node, options) {\r\n        //operations.docMethodOp\r\n        return line_widget.addLineWidget(this, handle, node, options);\r\n    },\r\n\r\n    removeLineWidget: function (widget) {\r\n        widget.clear();\r\n    },\r\n\r\n    markText: function (from, to, options) {\r\n        return mark_text.markText(this, this.clipPos( from), this.clipPos( to), options, options && options.type || 'range');\r\n    },\r\n\r\n    setBookmark: function (pos, options) {\r\n        let realOpts = {\r\n            replacedWith: options && (options.nodeType == null ? options.widget : options),\r\n            insertLeft: options && options.insertLeft,\r\n            clearWhenEmpty: false,\r\n            shared: options && options.shared,\r\n            handleMouseEvents: options && options.handleMouseEvents\r\n        };\r\n        pos = this.clipPos( pos);\r\n        return p.markText(this, pos, pos, realOpts, 'bookmark');\r\n    },\r\n\r\n    findMarksAt: function (pos) {\r\n        pos = this.clipPos( pos);\r\n        let markers = [], spans = this.getLineHandle(pos.line).markedSpans;\r\n        if (spans)\r\n            for (let i = 0; i < spans.length; ++i) {\r\n                let span = spans[i];\r\n                if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))\r\n                    markers.push(span.marker.parent || span.marker);\r\n            }\r\n        return markers;\r\n    },\r\n\r\n    findMarks: function (from, to, filter) {\r\n        from = this.clipPos( from);\r\n        to = this.clipPos( to);\r\n        let found = [], lineNo = from.line;\r\n        this.iter(from.line, to.line + 1, line => {\r\n            let spans = line.markedSpans;\r\n            if (spans)\r\n                for (let i = 0; i < spans.length; i++) {\r\n                    let span = spans[i];\r\n                    if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker)))\r\n                        found.push(span.marker.parent || span.marker);\r\n                }\r\n            ++lineNo;\r\n        });\r\n        return found;\r\n    },\r\n\r\n    getAllMarks: function () {\r\n        let markers = [];\r\n        this.iter(line => {\r\n            let sps = line.markedSpans;\r\n            if (sps)\r\n                for (let i = 0; i < sps.length; ++i)\r\n                    if (sps[i].from != null)\r\n                        markers.push(sps[i].marker);\r\n        });\r\n        return markers;\r\n    },\r\n\r\n    posFromIndex: function (off) {\r\n        let ch, lineNo = this.first, sepSize = this.lineSeparator().length;\r\n        this.iter(line => {\r\n            let sz = line.text.length + sepSize;\r\n            if (sz > off) {\r\n                ch = off;\r\n                return true;\r\n            }\r\n            off -= sz;\r\n            ++lineNo;\r\n        });\r\n        return this.clipPos( new Position(lineNo, ch));\r\n    },\r\n\r\n    indexFromPos: function (coords) {\r\n        coords = this.clipPos( coords);\r\n        let index = coords.ch;\r\n        if (coords.line < this.first || coords.ch < 0)\r\n            return 0;\r\n        let sepSize = this.lineSeparator().length;\r\n        this.iter(this.first, coords.line, line => {\r\n            index += line.text.length + sepSize;\r\n        });\r\n        return index;\r\n    },\r\n    copy: function (copyHistory) {\r\n        let doc = new Document(this.getLines(this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);\r\n        doc.scrollTop = this.scrollTop;\r\n        doc.scrollLeft = this.scrollLeft;\r\n        doc.sel = this.sel;\r\n        doc.extend = false;\r\n        if (copyHistory) {\r\n            doc.history.undoDepth = this.history.undoDepth;\r\n            doc.setHistory(this.getHistory());\r\n        }\r\n        return doc;\r\n    },\r\n\r\n    linkedDoc: function (options) {\r\n        if (!options)\r\n            options = {};\r\n        let from = this.first, to = this.first + this.size;\r\n        if (options.from != null && options.from > from)\r\n            from = options.from;\r\n        if (options.to != null && options.to < to)\r\n            to = options.to;\r\n        let copy = new Document(this.getLines(from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\r\n        if (options.sharedHist)\r\n            copy.history = this.history;\r\n        (this.linked || (this.linked = [])).push({\r\n            doc: copy,\r\n            sharedHist: options.sharedHist\r\n        });\r\n        copy.linked = [{\r\n                doc: this,\r\n                isParent: true,\r\n                sharedHist: options.sharedHist\r\n            }];\r\n        line_widget.copySharedMarkers(copy, line_widget.findSharedMarkers(this));\r\n        return copy;\r\n    },\r\n\r\n    unlinkDoc: function (other) {\r\n        //if (other instanceof CodeMirror) // modified by lwf\r\n        if (other.doc)\r\n            other = other.doc;\r\n        if (this.linked)\r\n            for (let i = 0; i < this.linked.length; ++i) {\r\n                let link = this.linked[i];\r\n                if (link.doc != other)\r\n                    continue;\r\n                this.linked.splice(i, 1);\r\n                other.unlinkDoc(this);\r\n                line_widget.detachSharedMarkers(line_widget.findSharedMarkers(this));\r\n                break;\r\n            }\r\n        if (other.history == this.history) {\r\n            let splitIds = [other.id];\r\n            document_data.linkedDocs(other, doc => splitIds.push(doc.id), true);\r\n            other.history = new m_history.History(null);\r\n            other.history.done = m_history.copyHistoryArray(this.history.done, splitIds);\r\n            other.history.undone = m_history.copyHistoryArray(this.history.undone, splitIds);\r\n        }\r\n    },\r\n\r\n    iterLinkedDocs: function (f) {\r\n        document_data.linkedDocs(this, f);\r\n    },\r\n\r\n    getMode: function () {\r\n        return this.mode;\r\n    },\r\n\r\n    getEditor: function () {\r\n        return this.cm;\r\n    },\r\n\r\n    splitLines: function (str) {\r\n        if (this.lineSep)\r\n            return str.split(this.lineSep);\r\n        return feature_detection.splitLinesAuto(str);\r\n    },\r\n\r\n    lineSeparator: function () {\r\n        return this.lineSep || '\\n';\r\n    },\r\n\r\n    setDirection: function (dir) {\r\n        //operations.docMethodOp\r\n        if (dir != 'rtl')\r\n            dir = 'ltr';\r\n        if (dir == this.direction)\r\n            return;\r\n        this.direction = dir;\r\n        this.iter(line => line.order = null);\r\n        ///if (this.cm)\r\n        ///    document_data.directionChanged(this.cm);\r\n        this.emit(\"directionChanged\");\r\n    }\r\n  });\r\n    \r\n  // Public alias.\r\n  Document.prototype.eachLine = Document.prototype.iter;\r\n\r\n  return plain.Document = Document;\r\n});\r\n\ndefine('skylark-texts-plain/main',[\r\n\t\"./plain\",\r\n\t\"./position\",\r\n\t\"./range\",\r\n\t\"./selection\",\r\n\t\"./line\",\r\n\t\"./leaf_chunk\",\r\n\t\"./branch_chunk\",\r\n\t\"./document\"\r\n],function(plain){\r\n\treturn plain;\r\n});\ndefine('skylark-texts-plain', ['skylark-texts-plain/main'], function (main) { return main; });\n\n"]}