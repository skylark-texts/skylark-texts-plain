{"version":3,"sources":["selection.js"],"names":["define","klass","plain","Position","Range","Selection","klassName","_construct","ranges","primIndex","this","primary","equals","other","length","i","here","there","compare","anchor","head","deepCopy","out","copyPos","somethingSelected","empty","contains","pos","end","range","from","to","normalize","mayTouch","prim","sort","a","b","arrays","indexOf","cur","prev","diff","min","max","inv","splice","simple"],"mappings":";;;;;;;AAAAA,QACE,sBACA,UACA,aACA,WACA,SAASC,EAAMC,EAAOC,EAAUC,GAIhC,IAAIC,EAAYJ,GACdK,UAAY,YAEZC,WAAa,SAAUC,EAAQC,GAC7BC,KAAKF,OAASA,EACdE,KAAKD,UAAYA,GAGnBE,QAAS,WACP,OAAOD,KAAKF,OAAOE,KAAKD,YAG1BG,OAAQ,SAASC,GACf,GAAIA,GAASH,KAAM,OAAO,EAC1B,GAAIG,EAAMJ,WAAaC,KAAKD,WAAaI,EAAML,OAAOM,QAAUJ,KAAKF,OAAOM,OAAQ,OAAO,EAC3F,IAAK,IAAIC,EAAI,EAAGA,EAAIL,KAAKF,OAAOM,OAAQC,IAAK,CAC3C,IAAIC,EAAON,KAAKF,OAAOO,GAAIE,EAAQJ,EAAML,OAAOO,GAChD,GAAmD,GAA/CZ,EAASe,QAAQF,EAAKG,OAAQF,EAAME,SAA2D,GAA3ChB,EAASe,QAAQF,EAAKI,KAAMH,EAAMG,MAAY,OAAO,EAE/G,OAAO,GAGTC,SAAU,WACR,IAAK,IAAIC,KAAUP,EAAI,EAAGA,EAAIL,KAAKF,OAAOM,OAAQC,IAChDO,EAAIP,GAAK,IAAIX,EAAMmB,QAAQb,KAAKF,OAAOO,GAAGI,QAASI,QAAQb,KAAKF,OAAOO,GAAGK,OAC5E,OAAO,IAAIf,EAAUiB,EAAKZ,KAAKD,YAGjCe,kBAAmB,WACjB,IAAK,IAAIT,EAAI,EAAGA,EAAIL,KAAKF,OAAOM,OAAQC,IACtC,IAAKL,KAAKF,OAAOO,GAAGU,QAAS,OAAO,EACtC,OAAO,GAGTC,SAAU,SAASC,EAAKC,GACjBA,IAAKA,EAAMD,GAChB,IAAK,IAAIZ,EAAI,EAAGA,EAAIL,KAAKF,OAAOM,OAAQC,IAAK,CAC3C,IAAIc,EAAQnB,KAAKF,OAAOO,GACxB,GAAIZ,EAASe,QAAQU,EAAKC,EAAMC,SAAW,GAAK3B,EAASe,QAAQS,EAAKE,EAAME,OAAS,EACnF,OAAOhB,EAEX,OAAQ,KAgCZ,OAvBAV,EAAU2B,UAAa,SAA4BC,EAAUzB,EAAQC,GAEjE,IAAIyB,EAAO1B,EAAOC,GAClBD,EAAO2B,KAAK,CAACC,EAAGC,IAAMlC,EAASe,QAAQkB,EAAEN,OAAQO,EAAEP,SACnDrB,EAAY6B,OAAOC,QAAQ/B,EAAQ0B,GACnC,IAAK,IAAInB,EAAI,EAAGA,EAAIP,EAAOM,OAAQC,IAAK,CACpC,IAAIyB,EAAMhC,EAAOO,GAAI0B,EAAOjC,EAAOO,EAAI,GACnC2B,EAAOvC,EAASe,QAAQuB,EAAKV,KAAMS,EAAIV,QAC3C,GAAIG,IAAaO,EAAIf,QAAUiB,EAAO,EAAIA,GAAQ,EAAG,CACjD,IAAIZ,EAAO3B,EAASwC,IAAIF,EAAKX,OAAQU,EAAIV,QAASC,EAAK5B,EAASyC,IAAIH,EAAKV,KAAMS,EAAIT,MAC/Ec,EAAMJ,EAAKhB,QAAUe,EAAIV,QAAUU,EAAIpB,KAAOqB,EAAKX,QAAUW,EAAKrB,KAClEL,GAAKN,KACHA,EACND,EAAOsC,SAAS/B,EAAG,EAAG,IAAIX,EAAMyC,EAAMd,EAAKD,EAAMe,EAAMf,EAAOC,KAGtE,OAAO,IAAI1B,EAAUG,EAAQC,IAGjCJ,EAAU0C,OAAU,SAAyB5B,EAAQC,GACnD,OAAO,IAAIf,GAAW,IAAID,EAAMe,EAAQC,GAAQD,IAAU,IAGrDjB,EAAMG,UAAYA","file":"../selection.js","sourcesContent":["define([\r\n  \"skylark-langx/klass\",\r\n  \"./plain\",\r\n  \"./position\",\r\n  \"./range\"\r\n],function(klass,plain, Position, Range) {\r\n\r\n  // Original: model/selection.js\r\n\r\n  var Selection = klass({\r\n    klassName : \"Selection\",\r\n\r\n    _construct : function (ranges, primIndex) {\r\n      this.ranges = ranges;\r\n      this.primIndex = primIndex;\r\n    },\r\n    \r\n    primary: function() { \r\n      return this.ranges[this.primIndex]; \r\n    },\r\n    \r\n    equals: function(other) {\r\n      if (other == this) return true;\r\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\r\n      for (var i = 0; i < this.ranges.length; i++) {\r\n        var here = this.ranges[i], there = other.ranges[i];\r\n        if (Position.compare(here.anchor, there.anchor) != 0 || Position.compare(here.head, there.head) != 0) return false;\r\n      }\r\n      return true;\r\n    },\r\n    \r\n    deepCopy: function() {\r\n      for (var out = [], i = 0; i < this.ranges.length; i++)\r\n        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\r\n      return new Selection(out, this.primIndex);\r\n    },\r\n    \r\n    somethingSelected: function() {\r\n      for (var i = 0; i < this.ranges.length; i++)\r\n        if (!this.ranges[i].empty()) return true;\r\n      return false;\r\n    },\r\n    \r\n    contains: function(pos, end) {\r\n      if (!end) end = pos;\r\n      for (var i = 0; i < this.ranges.length; i++) {\r\n        var range = this.ranges[i];\r\n        if (Position.compare(end, range.from()) >= 0 && Position.compare(pos, range.to()) <= 0)\r\n          return i;\r\n      }\r\n      return -1;\r\n    }\r\n\r\n  });\r\n\r\n  // Take an unsorted, potentially overlapping set of ranges, and\r\n  // build a selection out of it. 'Consumes' ranges array (modifying\r\n  // it).\r\n\r\n  Selection.normalize =  function normalizeSelection(mayTouch, ranges, primIndex) {\r\n      //let mayTouch = cm && cm.options.selectionsMayTouch;\r\n      let prim = ranges[primIndex];\r\n      ranges.sort((a, b) => Position.compare(a.from(), b.from()));\r\n      primIndex = arrays.indexOf(ranges, prim);\r\n      for (let i = 1; i < ranges.length; i++) {\r\n          let cur = ranges[i], prev = ranges[i - 1];\r\n          let diff = Position.compare(prev.to(), cur.from());\r\n          if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\r\n              let from = Position.min(prev.from(), cur.from()), to = Position.max(prev.to(), cur.to());\r\n              let inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\r\n              if (i <= primIndex)\r\n                  --primIndex;\r\n              ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\r\n          }\r\n      }\r\n      return new Selection(ranges, primIndex);\r\n  };\r\n\r\n  Selection.simple =  function simpleSelection(anchor, head) {\r\n    return new Selection([new Range(anchor, head || anchor)], 0);\r\n  };\r\n\r\n  return plain.Selection = Selection;\r\n});"]}