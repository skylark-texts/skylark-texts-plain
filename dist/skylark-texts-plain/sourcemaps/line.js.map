{"version":3,"sources":["line.js"],"names":["define","Evented","plain","Line","inherit","_construct","text","markedSpans","estimateHeight","this","attachMarkedSpans","updateLineHeight","height","lineNo","parent","cur","no","indexOf","lines","chunk","i","children","chunkSize","first","updateLine","stateAfter","styles","order","detachMarkedSpans","estHeight","cleanUpLine","countColumn","string","end","tabSize","startIndex","startValue","search","length","n","nextTab","findColumn","goal","pos","col","skipped","Math","min"],"mappings":";;;;;;;AAACA,QACC,wBACA,WACA,SAASC,EAAQC,GAMjB,IAAIC,EAAOF,EAAQG,SACjBC,WAAa,SAASC,EAAMC,EAAaC,GACvCC,KAAKH,KAAOA,EAERG,KAAKC,mBACPD,KAAKC,kBAAkBH,GAErBE,KAAKE,mBACPF,KAAKG,OAASJ,EAAiBA,EAAeC,MAAQ,IAI1DI,OAAS,WAGP,GAAmB,MADRJ,KACFK,OACP,OAAO,KAGT,IADA,IAAIC,EAJON,KAIIK,OAAQE,EAAKC,QAAQF,EAAIG,MAJ7BT,MAKFU,EAAQJ,EAAID,OAAQK,EAAOJ,EAAMI,EAAOA,EAAQA,EAAML,OAC7D,IAAK,IAAIM,EAAI,EACPD,EAAME,SAASD,IAAML,IADRK,EAEjBJ,GAAMG,EAAME,SAASD,GAAGE,YAG5B,OAAON,EAAKD,EAAIQ,OAMlBC,WAAa,SAAUlB,EAAMC,EAAaC,GAiBxC,GAhBWC,KAENH,KAAOA,EAFDG,KAGFgB,aAHEhB,KAGegB,WAAa,MAH5BhB,KAIFiB,SAJEjB,KAIWiB,OAAS,MACb,MALPjB,KAKFkB,QALElB,KAKkBkB,MAAQ,MAKjClB,KAAKmB,mBAVEnB,KAWJmB,oBAEHnB,KAAKC,mBAbED,KAcJC,kBAAmBH,GAEtBE,KAAKE,iBAAkB,CACzB,IAAIkB,EAAYrB,EAAiBA,EAjBxBC,MAiB+C,EACpDoB,GAlBKpB,KAkBaG,QAlBbH,KAkB0BE,iBAAiBkB,KAKxDC,YAAc,WACDrB,KACNK,OAAS,KAGVL,KAAKmB,mBAJEnB,KAKJmB,uBA8BOzB,EAAK4B,YAAc,SAASC,EAAQC,EAAKC,EAASC,EAAYC,GACnE,MAAPH,IAEU,IADZA,EAAMD,EAAOK,OAAO,kBACLJ,EAAMD,EAAOM,QAE9B,IAAK,IAAIlB,EAAIe,GAAc,EAAGI,EAAIH,GAAc,IAAK,CACnD,IAAII,EAAUR,EAAOf,QAAQ,KAAMG,GACnC,GAAIoB,EAAU,GAAKA,GAAWP,EAC5B,OAAOM,GAAKN,EAAMb,GACpBmB,GAAKC,EAAUpB,EACfmB,GAAKL,EAAWK,EAAIL,EACpBd,EAAIoB,EAAU,IAMDrC,EAAKsC,WAAa,SAAST,EAAQU,EAAMR,GACxD,IAAK,IAAIS,EAAM,EAAGC,EAAM,IAAK,CAC3B,IAAIJ,EAAUR,EAAOf,QAAQ,KAAM0B,IACnB,GAAZH,IAAeA,EAAUR,EAAOM,QACpC,IAAIO,EAAUL,EAAUG,EACxB,GAAIH,GAAWR,EAAOM,QAAUM,EAAMC,GAAWH,EAC/C,OAAOC,EAAMG,KAAKC,IAAIF,EAASH,EAAOE,GAIxC,GAHAA,GAAOJ,EAAUG,EAEjBA,EAAMH,EAAU,GADhBI,GAAOV,EAAWU,EAAMV,IAEbQ,EAAM,OAAOC,IAI5B,OAAOzC,EAAMC,KAAOA","file":"../line.js","sourcesContent":[" define([\r\n  \"skylark-langx/Evented\",\r\n  \"./plain\"\r\n],function(Evented,plain){\r\n\r\n  // LINE DATA STRUCTURE\r\n\r\n  // Line objects. These hold state related to a line, including\r\n  // highlighting info (the styles array).\r\n  var Line = Evented.inherit({\r\n    _construct : function(text, markedSpans, estimateHeight) {\r\n      this.text = text;\r\n      //TODO : The following logic will been changing\r\n      if (this.attachMarkedSpans) {\r\n        this.attachMarkedSpans(markedSpans);      \r\n      }\r\n      if (this.updateLineHeight) {\r\n        this.height = estimateHeight ? estimateHeight(this) : 1;\r\n      }\r\n    },\r\n\r\n    lineNo : function() { \r\n      //return lineNo(this); \r\n      var line = this;\r\n      if (line.parent == null) {\r\n        return null;\r\n      }\r\n      var cur = line.parent, no = indexOf(cur.lines, line);\r\n      for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\r\n        for (var i = 0;; ++i) {\r\n          if (chunk.children[i] == cur) break;\r\n          no += chunk.children[i].chunkSize();\r\n        }\r\n      }\r\n      return no + cur.first;\r\n    },\r\n\r\n    // Change the content (text, markers) of a line. Automatically\r\n    // invalidates cached information and tries to re-estimate the\r\n    // line's height.\r\n    updateLine : function (text, markedSpans, estimateHeight) {\r\n      var line = this;\r\n\r\n      line.text = text;\r\n      if (line.stateAfter) line.stateAfter = null;\r\n      if (line.styles) line.styles = null;\r\n      if (line.order != null) line.order = null;\r\n\r\n\r\n      //TODO : The following logic will been changing\r\n\r\n      if (this.detachMarkedSpans) {\r\n        line.detachMarkedSpans();\r\n      }\r\n      if (this.attachMarkedSpans) {\r\n        line.attachMarkedSpans( markedSpans);\r\n      }\r\n      if (this.updateLineHeight) {\r\n        var estHeight = estimateHeight ? estimateHeight(line) : 1;\r\n        if (estHeight != line.height) line.updateLineHeight(estHeight);\r\n      }\r\n    },\r\n\r\n    // Detach a line from the document tree and its markers.\r\n    cleanUpLine : function () {\r\n      var line = this;\r\n      line.parent = null;\r\n\r\n      //TODO : The following logic will been changing\r\n      if (this.detachMarkedSpans) {\r\n        line.detachMarkedSpans();\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n\r\n  function extractLineClasses(type, output) {\r\n    if (type) for (;;) {\r\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\r\n      if (!lineClass) break;\r\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\r\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\r\n      if (output[prop] == null)\r\n        output[prop] = lineClass[2];\r\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\r\n        output[prop] += \" \" + lineClass[2];\r\n    }\r\n    return type;\r\n  }\r\n\r\n  function callBlankLine(mode, state) {\r\n    if (mode.blankLine) return mode.blankLine(state);\r\n    if (!mode.innerMode) return;\r\n    var inner = CodeMirror.innerMode(mode, state);\r\n    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\r\n  }\r\n\r\n  // Counts the column offset in a string, taking tabs into account.\r\n  // Used mostly to find indentation.\r\n  var countColumn = Line.countColumn = function(string, end, tabSize, startIndex, startValue) {\r\n    if (end == null) {\r\n      end = string.search(/[^\\s\\u00a0]/);\r\n      if (end == -1) end = string.length;\r\n    }\r\n    for (var i = startIndex || 0, n = startValue || 0;;) {\r\n      var nextTab = string.indexOf(\"\\t\", i);\r\n      if (nextTab < 0 || nextTab >= end)\r\n        return n + (end - i);\r\n      n += nextTab - i;\r\n      n += tabSize - (n % tabSize);\r\n      i = nextTab + 1;\r\n    }\r\n  };\r\n\r\n  // The inverse of countColumn -- find the offset that corresponds to\r\n  // a particular column.\r\n  var findColumn = Line.findColumn = function(string, goal, tabSize) {\r\n    for (var pos = 0, col = 0;;) {\r\n      var nextTab = string.indexOf(\"\\t\", pos);\r\n      if (nextTab == -1) nextTab = string.length;\r\n      var skipped = nextTab - pos;\r\n      if (nextTab == string.length || col + skipped >= goal)\r\n        return pos + Math.min(skipped, goal - col);\r\n      col += nextTab - pos;\r\n      col += tabSize - (col % tabSize);\r\n      pos = nextTab + 1;\r\n      if (col >= goal) return pos;\r\n    }\r\n  }\r\n\r\n  return plain.Line = Line;\r\n\r\n});\r\n\r\n"]}