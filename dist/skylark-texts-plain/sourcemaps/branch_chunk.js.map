{"version":3,"sources":["branch_chunk.js"],"names":["define","Evented","plain","LeafChunk","BranchChunk","inherit","klassName","_construct","children","this","size","height","i","length","ch","chunkSize","parent","removeInner","at","n","child","sz","rm","Math","min","oldHeight","splice","lines","collapse","insertInner","remaining","pos","leaf","slice","maybeSpill","me","spilled","sibling","myIndex","indexOf","copy","iterN","op","used"],"mappings":"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","file":"../branch_chunk.js","sourcesContent":["define([\r\n  \"skylark-langx/Evented\",\r\n  \"./plain\",\r\n  \"./leaf_chunk\"\r\n],function(Evented,plain,LeafChunk){\r\n  // Original: model/chunk.js\r\n\r\n  var BranchChunk = Evented.inherit({\r\n    klassName : \"BranchChunk\",\r\n\r\n    _construct : function (children) {\r\n      this.children = children;\r\n      var size = 0, height = 0;\r\n      for (var i = 0; i < children.length; ++i) {\r\n        var ch = children[i];\r\n        size += ch.chunkSize(); height += ch.height;\r\n        ch.parent = this;\r\n      }\r\n      this.size = size;\r\n      this.height = height;\r\n      this.parent = null;\r\n    },\r\n\r\n    chunkSize: function() { \r\n      return this.size; \r\n    },\r\n    \r\n    removeInner: function(at, n) {\r\n      this.size -= n;\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at < sz) {\r\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\r\n          child.removeInner(at, rm);\r\n          this.height -= oldHeight - child.height;\r\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\r\n          if ((n -= rm) == 0) break;\r\n          at = 0;\r\n        } else at -= sz;\r\n      }\r\n      // If the result is smaller than 25 lines, ensure that it is a\r\n      // single leaf node.\r\n      if (this.size - n < 25 &&\r\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\r\n        var lines = [];\r\n        this.collapse(lines);\r\n        this.children = [new LeafChunk(lines)];\r\n        this.children[0].parent = this;\r\n      }\r\n    },\r\n\r\n    collapse: function(lines) {\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        this.children[i].collapse(lines);\r\n      }\r\n    },\r\n\r\n    insertInner: function(at, lines, height) {\r\n      this.size += lines.length;\r\n      this.height += height;\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at <= sz) {\r\n          child.insertInner(at, lines, height);\r\n          if (child.lines && child.lines.length > 50) {\r\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\r\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\r\n            var remaining = child.lines.length % 25 + 25\r\n            for (var pos = remaining; pos < child.lines.length;) {\r\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\r\n              child.height -= leaf.height;\r\n              this.children.splice(++i, 0, leaf);\r\n              leaf.parent = this;\r\n            }\r\n            child.lines = child.lines.slice(0, remaining);\r\n            this.maybeSpill();\r\n          }\r\n          break;\r\n        }\r\n        at -= sz;\r\n      }\r\n    },\r\n    // When a node has grown, check whether it should be split.\r\n    maybeSpill: function() {\r\n      if (this.children.length <= 10) return;\r\n      var me = this;\r\n      do {\r\n        var spilled = me.children.splice(me.children.length - 5, 5);\r\n        var sibling = new BranchChunk(spilled);\r\n        if (!me.parent) { // Become the parent node\r\n          var copy = new BranchChunk(me.children);\r\n          copy.parent = me;\r\n          me.children = [copy, sibling];\r\n          me = copy;\r\n       } else {\r\n          me.size -= sibling.size;\r\n          me.height -= sibling.height;\r\n          var myIndex = indexOf(me.parent.children, me);\r\n          me.parent.children.splice(myIndex + 1, 0, sibling);\r\n        }\r\n        sibling.parent = me.parent;\r\n      } while (me.children.length > 10);\r\n      me.parent.maybeSpill();\r\n    },\r\n    \r\n    iterN: function(at, n, op) {\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at < sz) {\r\n          var used = Math.min(n, sz - at);\r\n          if (child.iterN(at, used, op)) return true;\r\n          if ((n -= used) == 0) break;\r\n          at = 0;\r\n        } else at -= sz;\r\n      }\r\n    }\r\n  });\r\n\r\n  return plain.BranchChunk = BranchChunk;\r\n});\r\n"]}