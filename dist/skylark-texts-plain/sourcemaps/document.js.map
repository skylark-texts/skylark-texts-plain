{"version":3,"sources":["document.js"],"names":["define","arrays","Evented","plain","BranchChunk","LeafChunk","Position","Selection","History","nextDocId","Document","inherit","_construct","text","mode","firstLine","lineSep","direction","thie","overrited","Line","this","first","scrollTop","scrollLeft","cantEdit","cleanGeneration","modeFrontier","highlightFrontier","start","sel","simple","history","m_history","id","modeOption","extend","splitLines","document_data","updateDoc","from","to","selection_updates","setSelection","misc","sel_dontScroll","iter","op","iterN","size","insert","at","lines","height","i","length","insertInner","remove","n","removeInner","getValue","getLines","join","lineSeparator","setValue","code","top","last","changes","makeChange","getLineHandle","origin","full","cm","scrolling","scrollToCoords","replaceRange","clipPos","getRange","getBetween","end","out","line","slice","ch","push","getLine","l","Error","chunk","child","children","sz","chunkSize","getLineNumber","parent","cur","no","indexOf","getLineHandleVisualStart","spans","visualLine","isLine","lineCount","lastLine","pos","clipToLen","getCursor","range","primary","head","anchor","listSelections","ranges","somethingSelected","setCursor","options","setSimpleSelection","extendSelection","other","extendSelections","heads","m_pos","clipPosArray","extendSelectionsBy","f","map","setSelections","m_selection","Range","Math","min","primIndex","normalize","addSelection","normalizeSelection","getSelection","concat","getSelections","parts","replaceSelection","collapse","dup","replaceSelections","newSel","change_measurement","computeReplacedSel","setSelectionReplaceHistory","ensureCursorVisible","undo","makeChangeFromHistory","redo","undoSelection","redoSelection","setExtending","val","getExtending","historySize","hist","done","undone","clearHistory","maxGeneration","markClean","changeGeneration","forceSplit","lastOp","lastSelOp","lastOrigin","generation","isClean","gen","getHistory","copyHistoryArray","setHistory","histData","setGutterMarker","gutterID","value","changeLine","markers","gutterMarkers","isEmpty","clearGutter","lineInfo","handle","textClass","bgClass","wrapClass","widgets","addLineClass","where","cls","prop","dom","classTest","test","removeLineClass","found","match","index","addLineWidget","node","line_widget","removeLineWidget","widget","clear","markText","mark_text","type","setBookmark","realOpts","replacedWith","nodeType","insertLeft","clearWhenEmpty","shared","handleMouseEvents","p","findMarksAt","markedSpans","span","marker","findMarks","filter","lineNo","getAllMarks","sps","posFromIndex","off","sepSize","indexFromPos","coords","copy","copyHistory","doc","undoDepth","linkedDoc","sharedHist","linked","isParent","copySharedMarkers","findSharedMarkers","unlinkDoc","splice","detachSharedMarkers","splitIds","linkedDocs","iterLinkedDocs","getMode","getEditor","str","split","feature_detection","splitLinesAuto","setDirection","dir","order","emit","prototype","eachLine"],"mappings":"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","file":"../document.js","sourcesContent":["define([\r\n  \"skylark-langx/arrays\",\r\n  \"skylark-langx/Evented\",\r\n  \"./plain\",\r\n  \"./branch_chunk\",\r\n  \"./leaf_chunk\",\r\n  \"./position\",\r\n  \"./selection\",\r\n  \"./history\"\r\n],function(arrays, Evented,plain,BranchChunk,LeafChunk,Position,Selection, History){\r\n    // Original : model/doc.js \r\n    //TODO : selection_updates/history/marker\r\n    'use strict';\r\n    let nextDocId = 0;\r\n\r\n  // The document is represented as a BTree consisting of leaves, with\r\n  // chunk of lines in them, and branches, with up to ten leaves or\r\n  // other branch nodes below them. The top node is always a branch\r\n  // node, and is the document object itself (meaning it has\r\n  // additional methods and properties).\r\n  //\r\n  // All nodes have parent links. The tree is used both to go from\r\n  // line numbers to line objects, and to go from objects to numbers.\r\n  // It also indexes by height, and is used to convert between height\r\n  // and line object, and to find the total height of the document.\r\n  //\r\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\r\n  \r\n  var Document = BranchChunk.inherit({\r\n\r\n    _construct : function(text, mode, firstLine, lineSep,direction) {\r\n      if (firstLine == null) firstLine = 0;\r\n\r\n      thie.overrited(new LeafChunk([new Line(\"\", null)]));\r\n\r\n      this.first = firstLine;\r\n      this.scrollTop = this.scrollLeft = 0;\r\n      this.cantEdit = false;\r\n      this.cleanGeneration = 1;\r\n      this.modeFrontier = this.highlightFrontier = firstLine;\r\n      let start = new Position(firstLine, 0);\r\n      this.sel = Selection.simple(start);\r\n      this.history = new m_history.History(null);\r\n      this.id = ++nextDocId;\r\n      this.modeOption = mode;\r\n      this.lineSep = lineSep;\r\n      this.direction = direction == 'rtl' ? 'rtl' : 'ltr';\r\n      this.extend = false;\r\n      if (typeof text == 'string') {\r\n          text = this.splitLines(text);\r\n      }\r\n      document_data.updateDoc(this, {\r\n          from: start,\r\n          to: start,\r\n          text: text\r\n      });\r\n      selection_updates.setSelection(this, Selection.simple(start), misc.sel_dontScroll);\r\n    },\r\n\r\n    iter: function (from, to, op) {\r\n        if (op) {\r\n          this.iterN(from - this.first, to - from, op);\r\n        } else {\r\n          this.iterN(this.first, this.first + this.size, from);\r\n        }\r\n    },\r\n\r\n    insert: function (at, lines) {\r\n        let height = 0;\r\n        for (let i = 0; i < lines.length; ++i) {\r\n            height += lines[i].height;\r\n        }\r\n        this.insertInner(at - this.first, lines, height);\r\n    },\r\n\r\n    remove: function (at, n) {\r\n        this.removeInner(at - this.first, n);\r\n    },\r\n\r\n    getValue: function (lineSep) {\r\n        let lines = this.getLines(this.first, this.first + this.size);\r\n        if (lineSep === false)\r\n            return lines;\r\n        return lines.join(lineSep || this.lineSeparator());\r\n    },\r\n\r\n    setValue: function (code) {\r\n        //operations.docMethodOp\r\n        let top = new Position(this.first, 0), last = this.first + this.size - 1;\r\n        changes.makeChange(this, {\r\n            from: top,\r\n            to: new Position(last, this.getLineHandle(last).text.length),\r\n            text: this.splitLines(code),\r\n            origin: 'setValue',\r\n            full: true\r\n        }, true);\r\n        if (this.cm)\r\n            scrolling.scrollToCoords(this.cm, 0, 0);\r\n        selection_updates.setSelection(this, Selection.simple(top), misc.sel_dontScroll);\r\n    },\r\n\r\n    replaceRange: function (code, from, to, origin) {\r\n        from = this.clipPos( from);\r\n        to = to ? this.clipPos( to) : from;\r\n        changes.replaceRange(this, code, from, to, origin);\r\n    },\r\n\r\n    getRange: function (from, to, lineSep) {\r\n        let lines = this.getBetween(this.clipPos( from), this.clipPos( to));\r\n        if (lineSep === false)\r\n            return lines;\r\n        return lines.join(lineSep || this.lineSeparator());\r\n    },\r\n\r\n    getBetween : function (start, end) {\r\n        // moved from line/utils_line.js\r\n        let doc = this,\r\n            out = [], n = start.line;\r\n        doc.iter(start.line, end.line + 1, line => {\r\n            let text = line.text;\r\n            if (n == end.line)\r\n                text = text.slice(0, end.ch);\r\n            if (n == start.line)\r\n                text = text.slice(start.ch);\r\n            out.push(text);\r\n            ++n;\r\n        });\r\n        return out;\r\n    },\r\n\r\n    getLine: function (line) {\r\n        let l = this.getLineHandle(line);\r\n        return l && l.text;\r\n    },\r\n\r\n    getLines : function (from, to) {\r\n        // moved from line/utils_line.js\r\n        let doc = this,\r\n            out = [];\r\n        doc.iter(from, to, line => {\r\n            out.push(line.text);\r\n        });\r\n        return out;\r\n    },\r\n\r\n    getLineHandle: function (n) {\r\n        ///return utils_line.getLine(this, n);\r\n\r\n        // moved from line/utils_line.js\r\n        n -= this.first;\r\n        if (n < 0 || n >= this.size)\r\n            throw new Error('There is no line ' + (n + this.first) + ' in the document.');\r\n        let chunk = this;\r\n        while (!chunk.lines) {\r\n            for (let i = 0;; ++i) {\r\n                let child = chunk.children[i], sz = child.chunkSize();\r\n                if (n < sz) {\r\n                    chunk = child;\r\n                    break;\r\n                }\r\n                n -= sz;\r\n            }\r\n        }\r\n        return chunk.lines[n];\r\n    },\r\n\r\n    getLineNumber: function (line) {\r\n        ///return utils_line.lineNo(line);\r\n        // moved from line/utils_line.js\r\n        if (line.parent == null)\r\n            return null;\r\n        let cur = line.parent, no = arrays.indexOf(cur.lines, line);\r\n        for (let chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\r\n            for (let i = 0;; ++i) {\r\n                if (chunk.children[i] == cur)\r\n                    break;\r\n                no += chunk.children[i].chunkSize();\r\n            }\r\n        }\r\n        return no + cur.first;\r\n    },\r\n\r\n    getLineHandleVisualStart: function (line) {\r\n        if (typeof line == 'number')\r\n            line = this.getLineHandle(line);\r\n        return spans.visualLine(line);\r\n    },\r\n\r\n    isLine : function(l) {\r\n        // moved from line/utils_line.js\r\n        return l >= this.first && l < this.first + this.size;        \r\n    },\r\n\r\n    lineCount: function () {\r\n        return this.size;\r\n    },\r\n\r\n    firstLine: function () {\r\n        return this.first;\r\n    },\r\n\r\n    lastLine: function () {\r\n        return this.first + this.size - 1;\r\n    },\r\n\r\n    clipPos: function (pos) {\r\n        ///return m_pos.clipPos(this, pos);\r\n        //moved from line/pos.js\r\n        if (pos.line < this.first)\r\n            return  new Position(this.first, 0);\r\n        let last = this.first + this.size - 1;\r\n        if (pos.line > last)\r\n            return Position(last, this.getLineHandle(last).text.length);\r\n        return pos.clipToLen(this.getLineHandle(pos.line).text.length);\r\n    },\r\n\r\n    getCursor: function (start) {\r\n        let range = this.sel.primary(), pos;\r\n        if (start == null || start == 'head')\r\n            pos = range.head;\r\n        else if (start == 'anchor')\r\n            pos = range.anchor;\r\n        else if (start == 'end' || start == 'to' || start === false)\r\n            pos = range.to();\r\n        else\r\n            pos = range.from();\r\n        return pos;\r\n    },\r\n\r\n    listSelections: function () {\r\n        return this.sel.ranges;\r\n    },\r\n\r\n    somethingSelected: function () {\r\n        return this.sel.somethingSelected();\r\n    },\r\n\r\n\r\n    setCursor: function (line, ch, options) {\r\n        //operations.docMethodOp\r\n        selection_updates.setSimpleSelection(this, this.clipPos( typeof line == 'number' ? new Position(line, ch || 0) : line), null, options);\r\n    },\r\n\r\n    setSelection: function (anchor, head, options) {\r\n        //operations.docMethodOp\r\n        selection_updates.setSimpleSelection(this, this.clipPos( anchor), this.clipPos( head || anchor), options);\r\n    },\r\n\r\n    extendSelection: function (head, other, options) {\r\n        //operations.docMethodOp\r\n        selection_updates.extendSelection(this, this.clipPos( head), other && this.clipPos( other), options);\r\n    },\r\n\r\n    extendSelections: function (heads, options) {\r\n        //operations.docMethodOp\r\n        selection_updates.extendSelections(this, m_pos.clipPosArray(this, heads), options);\r\n    },\r\n\r\n    extendSelectionsBy: function (f, options) {\r\n        //operations.docMethodOp\r\n        let heads = misc.map(this.sel.ranges, f);\r\n        selection_updates.extendSelections(this, m_pos.clipPosArray(this, heads), options);\r\n    },\r\n\r\n    setSelections: function (ranges, primary, options) {\r\n        //operations.docMethodOp\r\n        if (!ranges.length)\r\n            return;\r\n        let out = [];\r\n        for (let i = 0; i < ranges.length; i++)\r\n            out[i] = new m_selection.Range(this.clipPos( ranges[i].anchor), this.clipPos( ranges[i].head));\r\n        if (primary == null)\r\n            primary = Math.min(ranges.length - 1, this.sel.primIndex);\r\n        selection_updates.setSelection(this, Selection.normalize(this.cm, out, primary), options);\r\n    },\r\n\r\n    addSelection: function (anchor, head, options) {\r\n        //operations.docMethodOp\r\n        let ranges = this.sel.ranges.slice(0);\r\n        ranges.push(new m_selection.Range(this.clipPos( anchor), this.clipPos( head || anchor)));\r\n        selection_updates.setSelection(this, m_selection.normalizeSelection(this.cm, ranges, ranges.length - 1), options);\r\n    },\r\n\r\n    getSelection: function (lineSep) {\r\n        let ranges = this.sel.ranges, lines;\r\n        for (let i = 0; i < ranges.length; i++) {\r\n            let sel = this.getBetween(ranges[i].from(), ranges[i].to());\r\n            lines = lines ? lines.concat(sel) : sel;\r\n        }\r\n        if (lineSep === false)\r\n            return lines;\r\n        else\r\n            return lines.join(lineSep || this.lineSeparator());\r\n    },\r\n    getSelections: function (lineSep) {\r\n        let parts = [], ranges = this.sel.ranges;\r\n        for (let i = 0; i < ranges.length; i++) {\r\n            let sel = this.getBetween(ranges[i].from(), ranges[i].to());\r\n            if (lineSep !== false)\r\n                sel = sel.join(lineSep || this.lineSeparator());\r\n            parts[i] = sel;\r\n        }\r\n        return parts;\r\n    },\r\n    replaceSelection: function (code, collapse, origin) {\r\n        let dup = [];\r\n        for (let i = 0; i < this.sel.ranges.length; i++)\r\n            dup[i] = code;\r\n        this.replaceSelections(dup, collapse, origin || '+input');\r\n    },\r\n\r\n    replaceSelections: function (code, collapse, origin) {\r\n        //operations.docMethodOp\r\n        let changes = [], sel = this.sel;\r\n        for (let i = 0; i < sel.ranges.length; i++) {\r\n            let range = sel.ranges[i];\r\n            changes[i] = {\r\n                from: range.from(),\r\n                to: range.to(),\r\n                text: this.splitLines(code[i]),\r\n                origin: origin\r\n            };\r\n        }\r\n        let newSel = collapse && collapse != 'end' && change_measurement.computeReplacedSel(this, changes, collapse);\r\n        for (let i = changes.length - 1; i >= 0; i--)\r\n            changes.makeChange(this, changes[i]);\r\n        if (newSel)\r\n            selection_updates.setSelectionReplaceHistory(this, newSel);\r\n        else if (this.cm)\r\n            scrolling.ensureCursorVisible(this.cm);\r\n    },\r\n\r\n    undo: function () {\r\n        //operations.docMethodOp\r\n        changes.makeChangeFromHistory(this, 'undo');\r\n    },\r\n\r\n    redo: function () {\r\n        //operations.docMethodOp\r\n        changes.makeChangeFromHistory(this, 'redo');\r\n    },\r\n\r\n    undoSelection: function () {\r\n        //operations.docMethodOp\r\n        changes.makeChangeFromHistory(this, 'undo', true);\r\n    },\r\n\r\n    redoSelection: function () {\r\n        //operations.docMethodOp\r\n        changes.makeChangeFromHistory(this, 'redo', true);\r\n    },\r\n\r\n    setExtending: function (val) {\r\n        this.extend = val;\r\n    },\r\n\r\n    getExtending: function () {\r\n        return this.extend;\r\n    },\r\n\r\n    historySize: function () {\r\n        let hist = this.history, done = 0, undone = 0;\r\n        for (let i = 0; i < hist.done.length; i++)\r\n            if (!hist.done[i].ranges)\r\n                ++done;\r\n        for (let i = 0; i < hist.undone.length; i++)\r\n            if (!hist.undone[i].ranges)\r\n                ++undone;\r\n        return {\r\n            undo: done,\r\n            redo: undone\r\n        };\r\n    },\r\n\r\n    clearHistory: function () {\r\n        this.history = new m_history.History(this.history.maxGeneration);\r\n    },\r\n\r\n    markClean: function () {\r\n        this.cleanGeneration = this.changeGeneration(true);\r\n    },\r\n\r\n    changeGeneration: function (forceSplit) {\r\n        if (forceSplit)\r\n            this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\r\n        return this.history.generation;\r\n    },\r\n\r\n    isClean: function (gen) {\r\n        return this.history.generation == (gen || this.cleanGeneration);\r\n    },\r\n\r\n    getHistory: function () {\r\n        return {\r\n            done: m_history.copyHistoryArray(this.history.done),\r\n            undone: m_history.copyHistoryArray(this.history.undone)\r\n        };\r\n    },\r\n\r\n    setHistory: function (histData) {\r\n        let hist = this.history = new m_history.History(this.history.maxGeneration);\r\n        hist.done = m_history.copyHistoryArray(histData.done.slice(0), null, true);\r\n        hist.undone = m_history.copyHistoryArray(histData.undone.slice(0), null, true);\r\n    },\r\n\r\n    setGutterMarker: function (line, gutterID, value) {\r\n        //operations.docMethodOp\r\n        return changes.changeLine(this, line, 'gutter', line => {\r\n            let markers = line.gutterMarkers || (line.gutterMarkers = {});\r\n            markers[gutterID] = value;\r\n            if (!value && misc.isEmpty(markers))\r\n                line.gutterMarkers = null;\r\n            return true;\r\n        });\r\n    },\r\n\r\n    clearGutter: function (gutterID) {\r\n        //operations.docMethodOp\r\n        this.iter(line => {\r\n            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\r\n                changes.changeLine(this, line, 'gutter', () => {\r\n                    line.gutterMarkers[gutterID] = null;\r\n                    if (misc.isEmpty(line.gutterMarkers))\r\n                        line.gutterMarkers = null;\r\n                    return true;\r\n                });\r\n            }\r\n        });\r\n    },\r\n\r\n    lineInfo: function (line) {\r\n        let n;\r\n        if (typeof line == 'number') {\r\n            if (!this.isLine(line))\r\n                return null;\r\n            n = line;\r\n            line = this.getLineHandle(line);\r\n            if (!line)\r\n                return null;\r\n        } else {\r\n            n = this.getLineNumber(line);\r\n            if (n == null)\r\n                return null;\r\n        }\r\n        return {\r\n            line: n,\r\n            handle: line,\r\n            text: line.text,\r\n            gutterMarkers: line.gutterMarkers,\r\n            textClass: line.textClass,\r\n            bgClass: line.bgClass,\r\n            wrapClass: line.wrapClass,\r\n            widgets: line.widgets\r\n        };\r\n    },\r\n\r\n    addLineClass: function (handle, where, cls) {\r\n        //operations.docMethodOp\r\n        return changes.changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', line => {\r\n            let prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';\r\n            if (!line[prop])\r\n                line[prop] = cls;\r\n            else if (dom.classTest(cls).test(line[prop]))\r\n                return false;\r\n            else\r\n                line[prop] += ' ' + cls;\r\n            return true;\r\n        });\r\n    },\r\n\r\n    removeLineClass: function (handle, where, cls) {\r\n        //operations.docMethodOp\r\n        return changes.changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', line => {\r\n            let prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';\r\n            let cur = line[prop];\r\n            if (!cur)\r\n                return false;\r\n            else if (cls == null)\r\n                line[prop] = null;\r\n            else {\r\n                let found = cur.match(dom.classTest(cls));\r\n                if (!found)\r\n                    return false;\r\n                let end = found.index + found[0].length;\r\n                line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? '' : ' ') + cur.slice(end) || null;\r\n            }\r\n            return true;\r\n        });\r\n    },\r\n\r\n    addLineWidget: function (handle, node, options) {\r\n        //operations.docMethodOp\r\n        return line_widget.addLineWidget(this, handle, node, options);\r\n    },\r\n\r\n    removeLineWidget: function (widget) {\r\n        widget.clear();\r\n    },\r\n\r\n    markText: function (from, to, options) {\r\n        return mark_text.markText(this, this.clipPos( from), this.clipPos( to), options, options && options.type || 'range');\r\n    },\r\n\r\n    setBookmark: function (pos, options) {\r\n        let realOpts = {\r\n            replacedWith: options && (options.nodeType == null ? options.widget : options),\r\n            insertLeft: options && options.insertLeft,\r\n            clearWhenEmpty: false,\r\n            shared: options && options.shared,\r\n            handleMouseEvents: options && options.handleMouseEvents\r\n        };\r\n        pos = this.clipPos( pos);\r\n        return p.markText(this, pos, pos, realOpts, 'bookmark');\r\n    },\r\n\r\n    findMarksAt: function (pos) {\r\n        pos = this.clipPos( pos);\r\n        let markers = [], spans = this.getLineHandle(pos.line).markedSpans;\r\n        if (spans)\r\n            for (let i = 0; i < spans.length; ++i) {\r\n                let span = spans[i];\r\n                if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))\r\n                    markers.push(span.marker.parent || span.marker);\r\n            }\r\n        return markers;\r\n    },\r\n\r\n    findMarks: function (from, to, filter) {\r\n        from = this.clipPos( from);\r\n        to = this.clipPos( to);\r\n        let found = [], lineNo = from.line;\r\n        this.iter(from.line, to.line + 1, line => {\r\n            let spans = line.markedSpans;\r\n            if (spans)\r\n                for (let i = 0; i < spans.length; i++) {\r\n                    let span = spans[i];\r\n                    if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker)))\r\n                        found.push(span.marker.parent || span.marker);\r\n                }\r\n            ++lineNo;\r\n        });\r\n        return found;\r\n    },\r\n\r\n    getAllMarks: function () {\r\n        let markers = [];\r\n        this.iter(line => {\r\n            let sps = line.markedSpans;\r\n            if (sps)\r\n                for (let i = 0; i < sps.length; ++i)\r\n                    if (sps[i].from != null)\r\n                        markers.push(sps[i].marker);\r\n        });\r\n        return markers;\r\n    },\r\n\r\n    posFromIndex: function (off) {\r\n        let ch, lineNo = this.first, sepSize = this.lineSeparator().length;\r\n        this.iter(line => {\r\n            let sz = line.text.length + sepSize;\r\n            if (sz > off) {\r\n                ch = off;\r\n                return true;\r\n            }\r\n            off -= sz;\r\n            ++lineNo;\r\n        });\r\n        return this.clipPos( new Position(lineNo, ch));\r\n    },\r\n\r\n    indexFromPos: function (coords) {\r\n        coords = this.clipPos( coords);\r\n        let index = coords.ch;\r\n        if (coords.line < this.first || coords.ch < 0)\r\n            return 0;\r\n        let sepSize = this.lineSeparator().length;\r\n        this.iter(this.first, coords.line, line => {\r\n            index += line.text.length + sepSize;\r\n        });\r\n        return index;\r\n    },\r\n    copy: function (copyHistory) {\r\n        let doc = new Document(this.getLines(this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);\r\n        doc.scrollTop = this.scrollTop;\r\n        doc.scrollLeft = this.scrollLeft;\r\n        doc.sel = this.sel;\r\n        doc.extend = false;\r\n        if (copyHistory) {\r\n            doc.history.undoDepth = this.history.undoDepth;\r\n            doc.setHistory(this.getHistory());\r\n        }\r\n        return doc;\r\n    },\r\n\r\n    linkedDoc: function (options) {\r\n        if (!options)\r\n            options = {};\r\n        let from = this.first, to = this.first + this.size;\r\n        if (options.from != null && options.from > from)\r\n            from = options.from;\r\n        if (options.to != null && options.to < to)\r\n            to = options.to;\r\n        let copy = new Document(this.getLines(from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\r\n        if (options.sharedHist)\r\n            copy.history = this.history;\r\n        (this.linked || (this.linked = [])).push({\r\n            doc: copy,\r\n            sharedHist: options.sharedHist\r\n        });\r\n        copy.linked = [{\r\n                doc: this,\r\n                isParent: true,\r\n                sharedHist: options.sharedHist\r\n            }];\r\n        line_widget.copySharedMarkers(copy, line_widget.findSharedMarkers(this));\r\n        return copy;\r\n    },\r\n\r\n    unlinkDoc: function (other) {\r\n        //if (other instanceof CodeMirror) // modified by lwf\r\n        if (other.doc)\r\n            other = other.doc;\r\n        if (this.linked)\r\n            for (let i = 0; i < this.linked.length; ++i) {\r\n                let link = this.linked[i];\r\n                if (link.doc != other)\r\n                    continue;\r\n                this.linked.splice(i, 1);\r\n                other.unlinkDoc(this);\r\n                line_widget.detachSharedMarkers(line_widget.findSharedMarkers(this));\r\n                break;\r\n            }\r\n        if (other.history == this.history) {\r\n            let splitIds = [other.id];\r\n            document_data.linkedDocs(other, doc => splitIds.push(doc.id), true);\r\n            other.history = new m_history.History(null);\r\n            other.history.done = m_history.copyHistoryArray(this.history.done, splitIds);\r\n            other.history.undone = m_history.copyHistoryArray(this.history.undone, splitIds);\r\n        }\r\n    },\r\n\r\n    iterLinkedDocs: function (f) {\r\n        document_data.linkedDocs(this, f);\r\n    },\r\n\r\n    getMode: function () {\r\n        return this.mode;\r\n    },\r\n\r\n    getEditor: function () {\r\n        return this.cm;\r\n    },\r\n\r\n    splitLines: function (str) {\r\n        if (this.lineSep)\r\n            return str.split(this.lineSep);\r\n        return feature_detection.splitLinesAuto(str);\r\n    },\r\n\r\n    lineSeparator: function () {\r\n        return this.lineSep || '\\n';\r\n    },\r\n\r\n    setDirection: function (dir) {\r\n        //operations.docMethodOp\r\n        if (dir != 'rtl')\r\n            dir = 'ltr';\r\n        if (dir == this.direction)\r\n            return;\r\n        this.direction = dir;\r\n        this.iter(line => line.order = null);\r\n        ///if (this.cm)\r\n        ///    document_data.directionChanged(this.cm);\r\n        this.emit(\"directionChanged\");\r\n    }\r\n  });\r\n    \r\n  // Public alias.\r\n  Document.prototype.eachLine = Document.prototype.iter;\r\n\r\n  return plain.Document = Document;\r\n});\r\n"]}