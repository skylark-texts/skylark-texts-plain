{"version":3,"sources":["history.js"],"names":["define","arrays","Position","Selection","History","startGen","this","done","undone","undoDepth","Infinity","lastModTime","lastSelTime","lastOp","lastSelOp","lastOrigin","lastSelOrigin","generation","maxGeneration","historyChangeFromChange","doc","change","histChange","from","copy","to","change_measurement","changeEnd","text","getBetween","attachLocalSpans","line","document_data","linkedDocs","clearSelectionEvents","array","length","last","ranges","pop","pushSelectionToHistory","sel","dest","top","equals","push","existing","id","n","iter","Math","max","first","min","size","markedSpans","removeClearedSpans","spans","out","i","marker","explicitlyCleared","slice","addChangeToHistory","selAfter","opId","hist","history","cur","time","Date","origin","charAt","cm","options","historyEventDelay","force","lastChangeEvent","changes","compare","before","shift","emit","addSelectionToHistory","prev","ch","somethingSelected","selectionEventCanBeMerged","clearRedo","mergeOldSpans","old","found","nw","getOldSpans","stretched","stretchSpansOverChange","oldCur","stretchCur","j","span","k","copyHistoryArray","events","newGroup","instantiateSel","event","prototype","deepCopy","call","newChanges","m","prop","match","indexOf","Number"],"mappings":"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","file":"../history.js","sourcesContent":["define([\r\n    \"skylark-langx-arrays\",\r\n    './position',\r\n    './selection'\r\n], function (arrays,Position,  Selection) {\r\n    'use strict';\r\n\r\n    //TODO:spans/change_measurement/document_data\r\n\r\n    function History(startGen) {\r\n        this.done = [];\r\n        this.undone = [];\r\n        this.undoDepth = Infinity;\r\n        this.lastModTime = this.lastSelTime = 0;\r\n        this.lastOp = this.lastSelOp = null;\r\n        this.lastOrigin = this.lastSelOrigin = null;\r\n        this.generation = this.maxGeneration = startGen || 1;\r\n    }\r\n\r\n    function historyChangeFromChange(doc, change) {\r\n        let histChange = {\r\n            from: Position.copy(change.from),\r\n            to: change_measurement.changeEnd(change),\r\n            text: doc.getBetween(change.from, change.to)\r\n        };\r\n        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\r\n        document_data.linkedDocs(doc, doc => attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1), true);\r\n        return histChange;\r\n    }\r\n\r\n    function clearSelectionEvents(array) {\r\n        while (array.length) {\r\n            let last = arrays.last(array);\r\n            if (last.ranges)\r\n                array.pop();\r\n            else\r\n                break;\r\n        }\r\n    }\r\n\r\n    function lastChangeEvent(hist, force) {\r\n        if (force) {\r\n            clearSelectionEvents(hist.done);\r\n            return arrays.last(hist.done);\r\n        } else if (hist.done.length && !arrays.last(hist.done).ranges) {\r\n            return arrays.last(hist.done);\r\n        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\r\n            hist.done.pop();\r\n            return arrays.last(hist.done);\r\n        }\r\n    }\r\n    function addChangeToHistory(doc, change, selAfter, opId) {\r\n        let hist = doc.history;\r\n        hist.undone.length = 0;\r\n        let time = +new Date(), cur;\r\n        let last;\r\n        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == '*')) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\r\n            last = arrays.last(cur.changes);\r\n            if (Position.compare(change.from, change.to) == 0 && Position.compare(change.from, last.to) == 0) {\r\n                last.to = change_measurement.changeEnd(change);\r\n            } else {\r\n                cur.changes.push(historyChangeFromChange(doc, change));\r\n            }\r\n        } else {\r\n            let before = arrays.last(hist.done);\r\n            if (!before || !before.ranges)\r\n                pushSelectionToHistory(doc.sel, hist.done);\r\n            cur = {\r\n                changes: [historyChangeFromChange(doc, change)],\r\n                generation: hist.generation\r\n            };\r\n            hist.done.push(cur);\r\n            while (hist.done.length > hist.undoDepth) {\r\n                hist.done.shift();\r\n                if (!hist.done[0].ranges)\r\n                    hist.done.shift();\r\n            }\r\n        }\r\n        hist.done.push(selAfter);\r\n        hist.generation = ++hist.maxGeneration;\r\n        hist.lastModTime = hist.lastSelTime = time;\r\n        hist.lastOp = hist.lastSelOp = opId;\r\n        hist.lastOrigin = hist.lastSelOrigin = change.origin;\r\n        if (!last)\r\n            doc.emit('historyAdded');\r\n    }\r\n\r\n    function selectionEventCanBeMerged(doc, origin, prev, sel) {\r\n        let ch = origin.charAt(0);\r\n        return ch == '*' || ch == '+' && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\r\n    }\r\n\r\n    function addSelectionToHistory(doc, sel, opId, options) {\r\n        let hist = doc.history, origin = options && options.origin;\r\n        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, arrays.last(hist.done), sel)))\r\n            hist.done[hist.done.length - 1] = sel;\r\n        else\r\n            pushSelectionToHistory(sel, hist.done);\r\n        hist.lastSelTime = +new Date();\r\n        hist.lastSelOrigin = origin;\r\n        hist.lastSelOp = opId;\r\n        if (options && options.clearRedo !== false)\r\n            clearSelectionEvents(hist.undone);\r\n    }\r\n\r\n    function pushSelectionToHistory(sel, dest) {\r\n        let top = arrays.last(dest);\r\n        if (!(top && top.ranges && top.equals(sel)))\r\n            dest.push(sel);\r\n    }\r\n\r\n    function attachLocalSpans(doc, change, from, to) {\r\n        let existing = change['spans_' + doc.id], n = 0;\r\n        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), line => {\r\n            if (line.markedSpans)\r\n                (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;\r\n            ++n;\r\n        });\r\n    }\r\n\r\n    function removeClearedSpans(spans) {\r\n        if (!spans)\r\n            return null;\r\n        let out;\r\n        for (let i = 0; i < spans.length; ++i) {\r\n            if (spans[i].marker.explicitlyCleared) {\r\n                if (!out)\r\n                    out = spans.slice(0, i);\r\n            } else if (out)\r\n                out.push(spans[i]);\r\n        }\r\n        return !out ? spans : out.length ? out : null;\r\n    }\r\n\r\n    function getOldSpans(doc, change) {\r\n        let found = change['spans_' + doc.id];\r\n        if (!found)\r\n            return null;\r\n        let nw = [];\r\n        for (let i = 0; i < change.text.length; ++i)\r\n            nw.push(removeClearedSpans(found[i]));\r\n        return nw;\r\n    }\r\n\r\n    function mergeOldSpans(doc, change) {\r\n        let old = getOldSpans(doc, change);\r\n        let stretched = spans.stretchSpansOverChange(doc, change);\r\n        if (!old)\r\n            return stretched;\r\n        if (!stretched)\r\n            return old;\r\n        for (let i = 0; i < old.length; ++i) {\r\n            let oldCur = old[i], stretchCur = stretched[i];\r\n            if (oldCur && stretchCur) {\r\n                spans:\r\n                    for (let j = 0; j < stretchCur.length; ++j) {\r\n                        let span = stretchCur[j];\r\n                        for (let k = 0; k < oldCur.length; ++k)\r\n                            if (oldCur[k].marker == span.marker)\r\n                                continue spans;\r\n                        oldCur.push(span);\r\n                    }\r\n            } else if (stretchCur) {\r\n                old[i] = stretchCur;\r\n            }\r\n        }\r\n        return old;\r\n    }\r\n\r\n    function copyHistoryArray(events, newGroup, instantiateSel) {\r\n        let copy = [];\r\n        for (let i = 0; i < events.length; ++i) {\r\n            let event = events[i];\r\n            if (event.ranges) {\r\n                copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\r\n                continue;\r\n            }\r\n            let changes = event.changes, newChanges = [];\r\n            copy.push({ changes: newChanges });\r\n            for (let j = 0; j < changes.length; ++j) {\r\n                let change = changes[j], m;\r\n                newChanges.push({\r\n                    from: change.from,\r\n                    to: change.to,\r\n                    text: change.text\r\n                });\r\n                if (newGroup)\r\n                    for (var prop in change)\r\n                        if (m = prop.match(/^spans_(\\d+)$/)) {\r\n                            if (arrays.indexOf(newGroup, Number(m[1])) > -1) {\r\n                                arrays.last(newChanges)[prop] = change[prop];\r\n                                delete change[prop];\r\n                            }\r\n                        }\r\n            }\r\n        }\r\n        return copy;\r\n    }\r\n\r\n    History.historyChangeFromChange = historyChangeFromChange;\r\n    History.addChangeToHistory = addChangeToHistory;\r\n    History.addSelectionToHistory = addSelectionToHistory;\r\n    History.pushSelectionToHistory = pushSelectionToHistory;\r\n    History.mergeOldSpans = mergeOldSpans;\r\n    History.copyHistoryArray = copyHistoryArray;\r\n\r\n    return History;\r\n});"]}